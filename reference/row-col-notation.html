<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en-US"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Row and column notation — row-col-notation • RCLabels</title><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet"><link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet"><script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Row and column notation — row-col-notation"><meta name="description" content="It is often convenient to represent matrix row and column names
with notation that includes a prefix and a suffix,
with corresponding separators or start-end string sequences.
There are several functions to generate specialized versions
or otherwise manipulate row and column names on their own or as row or column names.
flip_pref_suff() Switches the location of prefix and suffix, such that the prefix becomes the suffix, and
the suffix becomes the prefix.
E.g., &quot;a -&amp;gt; b&quot; becomes &quot;b -&amp;gt; a&quot; or &quot;a [b]&quot; becomes &quot;b [a]&quot;.
get_pref_suff() Selects only prefix or suffix, discarding notational elements
and the rejected part.
Internally, this function calls split_pref_suff() and selects only the desired portion.
notation_vec() Builds a vector of notation symbols in a standard format.
By default, it builds a list of notation symbols that provides an arrow
separator (&quot; -&amp;gt; &quot;) between prefix and suffix.
paste_pref_suff() paste0's prefixes and suffixes, the inverse of split_pref_suff().
Always returns a character vector.
preposition_notation() Builds a list of notation symbols that provides (by default) square brackets around the suffix with a preposition (&quot;prefix [preposition suffix]&quot;).
split_pref_suff() Splits prefixes from suffixes, returning each in a list with names pref and suff.
If no prefix or suffix delimiters are found, x is returned in the pref item, unmodified,
and the suff item is returned as &quot;&quot; (an empty string).
If there is no prefix, and empty string is returned for the pref item.
If there is no suffix, and empty string is returned for the suff item.
switch_notation() Switches from one type of notation to another based on the from and to arguments.
Optionally, prefix and suffix can be flipped.


Parts of a notation vector are
&quot;pref_start&quot;, &quot;pref_end&quot;, &quot;suff_start&quot;, and &quot;suff_end&quot;.
None of the strings in a notation vector are considered part of the prefix or suffix.
E.g., &quot;a -&amp;gt; b&quot; in arrow notation means that &quot;a&quot; is the prefix and &quot;b&quot; is the suffix.
If sep only is specified for notation_vec() (default is &quot; -&amp;gt; &quot;),
pref_start, pref_end, suff_start, and suff_end are
set appropriately.
For functions where the notation argument is used to identify portions of the row or column label
(such as split_pref_suff(), get_pref_suff(),
and the from argument to switch_notation()),
(Note: flip_pref_suff() cannot infer notation, because it switches prefix and suffix in a known, single notation.)
if notation is a list, it is treated as a store from which
the most appropriate notation is inferred by infer_notation(choose_most_specific = TRUE).
Because default is RCLabels::notations_list,
notation is inferred by default.
The argument choose_most_specific tells what to do when two notations match a label:
if TRUE (the default), the notation with most characters is selected.
If FALSE, the first matching notation in notation will be selected.
See details at infer_notation().
If specifying more than one notation, be sure the notations are in a list.
notation = c(RCLabels::bracket_notation, RCLabels::arrow_notation)
is unlikely to produce the desired result, because the notations
are concatenated together to form a long string vector.
Rather say
notation = list(RCLabels::bracket_notation, RCLabels::arrow_notation).
For functions that construct labels (such as paste_pref_suff()),
notation can be a list of notations
over which the paste tasks is mapped.
If notation is a list, it must have as many items as
there are prefix/suffix pairs to be pasted.
If either pref or suff are a zero-length character vector
(essentially an empty character vector
such as obtained from character())
input to paste_pref_suff(),
an error is thrown.
Instead, use an empty character string
(such as obtained from &quot;&quot;)."><meta property="og:description" content="It is often convenient to represent matrix row and column names
with notation that includes a prefix and a suffix,
with corresponding separators or start-end string sequences.
There are several functions to generate specialized versions
or otherwise manipulate row and column names on their own or as row or column names.
flip_pref_suff() Switches the location of prefix and suffix, such that the prefix becomes the suffix, and
the suffix becomes the prefix.
E.g., &quot;a -&amp;gt; b&quot; becomes &quot;b -&amp;gt; a&quot; or &quot;a [b]&quot; becomes &quot;b [a]&quot;.
get_pref_suff() Selects only prefix or suffix, discarding notational elements
and the rejected part.
Internally, this function calls split_pref_suff() and selects only the desired portion.
notation_vec() Builds a vector of notation symbols in a standard format.
By default, it builds a list of notation symbols that provides an arrow
separator (&quot; -&amp;gt; &quot;) between prefix and suffix.
paste_pref_suff() paste0's prefixes and suffixes, the inverse of split_pref_suff().
Always returns a character vector.
preposition_notation() Builds a list of notation symbols that provides (by default) square brackets around the suffix with a preposition (&quot;prefix [preposition suffix]&quot;).
split_pref_suff() Splits prefixes from suffixes, returning each in a list with names pref and suff.
If no prefix or suffix delimiters are found, x is returned in the pref item, unmodified,
and the suff item is returned as &quot;&quot; (an empty string).
If there is no prefix, and empty string is returned for the pref item.
If there is no suffix, and empty string is returned for the suff item.
switch_notation() Switches from one type of notation to another based on the from and to arguments.
Optionally, prefix and suffix can be flipped.


Parts of a notation vector are
&quot;pref_start&quot;, &quot;pref_end&quot;, &quot;suff_start&quot;, and &quot;suff_end&quot;.
None of the strings in a notation vector are considered part of the prefix or suffix.
E.g., &quot;a -&amp;gt; b&quot; in arrow notation means that &quot;a&quot; is the prefix and &quot;b&quot; is the suffix.
If sep only is specified for notation_vec() (default is &quot; -&amp;gt; &quot;),
pref_start, pref_end, suff_start, and suff_end are
set appropriately.
For functions where the notation argument is used to identify portions of the row or column label
(such as split_pref_suff(), get_pref_suff(),
and the from argument to switch_notation()),
(Note: flip_pref_suff() cannot infer notation, because it switches prefix and suffix in a known, single notation.)
if notation is a list, it is treated as a store from which
the most appropriate notation is inferred by infer_notation(choose_most_specific = TRUE).
Because default is RCLabels::notations_list,
notation is inferred by default.
The argument choose_most_specific tells what to do when two notations match a label:
if TRUE (the default), the notation with most characters is selected.
If FALSE, the first matching notation in notation will be selected.
See details at infer_notation().
If specifying more than one notation, be sure the notations are in a list.
notation = c(RCLabels::bracket_notation, RCLabels::arrow_notation)
is unlikely to produce the desired result, because the notations
are concatenated together to form a long string vector.
Rather say
notation = list(RCLabels::bracket_notation, RCLabels::arrow_notation).
For functions that construct labels (such as paste_pref_suff()),
notation can be a list of notations
over which the paste tasks is mapped.
If notation is a list, it must have as many items as
there are prefix/suffix pairs to be pasted.
If either pref or suff are a zero-length character vector
(essentially an empty character vector
such as obtained from character())
input to paste_pref_suff(),
an error is thrown.
Instead, use an empty character string
(such as obtained from &quot;&quot;)."></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">RCLabels</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.1.12</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="nav-item"><a class="nav-link" href="../articles/RCLabels.html">Get started</a></li>
<li class="active nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul><ul class="navbar-nav"><li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json"></form></li>
      </ul></div>


  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Row and column notation</h1>

      <div class="d-none name"><code>row-col-notation.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p>It is often convenient to represent matrix row and column names
with notation that includes a prefix and a suffix,
with corresponding separators or start-end string sequences.
There are several functions to generate specialized versions
or otherwise manipulate row and column names on their own or as row or column names.</p><ul><li><p><code>flip_pref_suff()</code> Switches the location of prefix and suffix, such that the prefix becomes the suffix, and
the suffix becomes the prefix.
E.g., "a -&gt; b" becomes "b -&gt; a" or "a [b]" becomes "b [a]".</p></li>
<li><p><code>get_pref_suff()</code> Selects only prefix or suffix, discarding notational elements
and the rejected part.
Internally, this function calls <code>split_pref_suff()</code> and selects only the desired portion.</p></li>
<li><p><code>notation_vec()</code> Builds a vector of notation symbols in a standard format.
By default, it builds a list of notation symbols that provides an arrow
separator (" -&gt; ") between prefix and suffix.</p></li>
<li><p><code>paste_pref_suff()</code> <code>paste0</code>'s prefixes and suffixes, the inverse of <code>split_pref_suff()</code>.
Always returns a character vector.</p></li>
<li><p><code>preposition_notation()</code> Builds a list of notation symbols that provides (by default) square brackets around the suffix with a preposition ("prefix [preposition suffix]").</p></li>
<li><p><code>split_pref_suff()</code> Splits prefixes from suffixes, returning each in a list with names <code>pref</code> and <code>suff</code>.
If no prefix or suffix delimiters are found, <code>x</code> is returned in the <code>pref</code> item, unmodified,
and the <code>suff</code> item is returned as <code>""</code> (an empty string).
If there is no prefix, and empty string is returned for the <code>pref</code> item.
If there is no suffix, and empty string is returned for the <code>suff</code> item.</p></li>
<li><p><code>switch_notation()</code> Switches from one type of notation to another based on the <code>from</code> and <code>to</code> arguments.
Optionally, prefix and suffix can be <code>flip</code>ped.</p></li>
</ul><p>Parts of a <code>notation</code> vector are
"pref_start", "pref_end", "suff_start", and "suff_end".
None of the strings in a notation vector are considered part of the prefix or suffix.
E.g., "a -&gt; b" in arrow notation means that "a" is the prefix and "b" is the suffix.
If <code>sep</code> only is specified for <code>notation_vec()</code> (default is " -&gt; "),
<code>pref_start</code>, <code>pref_end</code>, <code>suff_start</code>, and <code>suff_end</code> are
set appropriately.</p>
<p>For functions where the <code>notation</code> argument is used to identify portions of the row or column label
(such as <code>split_pref_suff()</code>, <code>get_pref_suff()</code>,
and the <code>from</code> argument to <code>switch_notation()</code>),
(Note: <code>flip_pref_suff()</code> cannot infer notation, because it switches prefix and suffix in a known, single notation.)
if <code>notation</code> is a list, it is treated as a store from which
the most appropriate notation is inferred by <code>infer_notation(choose_most_specific = TRUE)</code>.
Because default is <code><a href="notations_list.html">RCLabels::notations_list</a></code>,
notation is inferred by default.
The argument <code>choose_most_specific</code> tells what to do when two <code>notation</code>s match a label:
if <code>TRUE</code> (the default), the notation with most characters is selected.
If <code>FALSE</code>, the first matching notation in <code>notation</code> will be selected.
See details at <code><a href="infer_notation.html">infer_notation()</a></code>.</p>
<p>If specifying more than one <code>notation</code>, be sure the notations are in a list.
<code>notation = c(RCLabels::bracket_notation, RCLabels::arrow_notation)</code>
is unlikely to produce the desired result, because the notations
are concatenated together to form a long string vector.
Rather say
<code>notation = list(RCLabels::bracket_notation, RCLabels::arrow_notation)</code>.</p>
<p>For functions that construct labels (such as <code>paste_pref_suff()</code>),
<code>notation</code> can be a list of notations
over which the paste tasks is mapped.
If <code>notation</code> is a list, it must have as many items as
there are prefix/suffix pairs to be pasted.</p>
<p>If either <code>pref</code> or <code>suff</code> are a zero-length character vector
(essentially an empty character vector
such as obtained from <code><a href="https://rdrr.io/r/base/character.html" class="external-link">character()</a></code>)
input to <code>paste_pref_suff()</code>,
an error is thrown.
Instead, use an empty character string
(such as obtained from <code>""</code>).</p>
    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">notation_vec</span><span class="op">(</span></span>
<span>  sep <span class="op">=</span> <span class="st">" -&gt; "</span>,</span>
<span>  pref_start <span class="op">=</span> <span class="st">""</span>,</span>
<span>  pref_end <span class="op">=</span> <span class="st">""</span>,</span>
<span>  suff_start <span class="op">=</span> <span class="st">""</span>,</span>
<span>  suff_end <span class="op">=</span> <span class="st">""</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="fu">preposition_notation</span><span class="op">(</span><span class="va">preposition</span>, suff_start <span class="op">=</span> <span class="st">" ["</span>, suff_end <span class="op">=</span> <span class="st">"]"</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">split_pref_suff</span><span class="op">(</span></span>
<span>  <span class="va">x</span>,</span>
<span>  transpose <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  inf_notation <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  notation <span class="op">=</span> <span class="fu">RCLabels</span><span class="fu">::</span><span class="va"><a href="notations_list.html">notations_list</a></span>,</span>
<span>  choose_most_specific <span class="op">=</span> <span class="cn">TRUE</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="fu">paste_pref_suff</span><span class="op">(</span></span>
<span>  ps <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>pref <span class="op">=</span> <span class="va">pref</span>, suff <span class="op">=</span> <span class="va">suff</span><span class="op">)</span>,</span>
<span>  pref <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  suff <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  notation <span class="op">=</span> <span class="fu">RCLabels</span><span class="fu">::</span><span class="va"><a href="arrow_notation.html">arrow_notation</a></span>,</span>
<span>  squish <span class="op">=</span> <span class="cn">TRUE</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="fu">flip_pref_suff</span><span class="op">(</span></span>
<span>  <span class="va">x</span>,</span>
<span>  notation <span class="op">=</span> <span class="fu">RCLabels</span><span class="fu">::</span><span class="va"><a href="notations_list.html">notations_list</a></span>,</span>
<span>  inf_notation <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  choose_most_specific <span class="op">=</span> <span class="cn">TRUE</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="fu">get_pref_suff</span><span class="op">(</span></span>
<span>  <span class="va">x</span>,</span>
<span>  which <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"pref"</span>, <span class="st">"suff"</span><span class="op">)</span>,</span>
<span>  inf_notation <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  notation <span class="op">=</span> <span class="fu">RCLabels</span><span class="fu">::</span><span class="va"><a href="notations_list.html">notations_list</a></span>,</span>
<span>  choose_most_specific <span class="op">=</span> <span class="cn">TRUE</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="fu">switch_notation</span><span class="op">(</span></span>
<span>  <span class="va">x</span>,</span>
<span>  from <span class="op">=</span> <span class="fu">RCLabels</span><span class="fu">::</span><span class="va"><a href="notations_list.html">notations_list</a></span>,</span>
<span>  <span class="va">to</span>,</span>
<span>  flip <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  inf_notation <span class="op">=</span> <span class="cn">TRUE</span></span>
<span><span class="op">)</span></span></code></pre></div>
    </div>

    <div class="section level2">
    <h2 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h2>


<dl><dt id="arg-sep">sep<a class="anchor" aria-label="anchor" href="#arg-sep"></a></dt>
<dd><p>A string separator between prefix and suffix. Default is " -&gt; ".</p></dd>


<dt id="arg-pref-start">pref_start<a class="anchor" aria-label="anchor" href="#arg-pref-start"></a></dt>
<dd><p>A string indicating the start of a prefix. Default is <code>NULL</code>.</p></dd>


<dt id="arg-pref-end">pref_end<a class="anchor" aria-label="anchor" href="#arg-pref-end"></a></dt>
<dd><p>A string indicating the end of a prefix. Default is the value of <code>sep</code>.</p></dd>


<dt id="arg-suff-start">suff_start<a class="anchor" aria-label="anchor" href="#arg-suff-start"></a></dt>
<dd><p>A string indicating the start of a suffix. Default is the value of <code>sep</code>.</p></dd>


<dt id="arg-suff-end">suff_end<a class="anchor" aria-label="anchor" href="#arg-suff-end"></a></dt>
<dd><p>A string indicating the end of a suffix. Default is <code>NULL</code>.</p></dd>


<dt id="arg-preposition">preposition<a class="anchor" aria-label="anchor" href="#arg-preposition"></a></dt>
<dd><p>A string used to indicate position for energy flows, typically "from" or "to" in different notations.</p></dd>


<dt id="arg-x">x<a class="anchor" aria-label="anchor" href="#arg-x"></a></dt>
<dd><p>A string or vector of strings to be operated upon.</p></dd>


<dt id="arg-transpose">transpose<a class="anchor" aria-label="anchor" href="#arg-transpose"></a></dt>
<dd><p>A boolean that tells whether to <code>purr::transpose()</code> the result.
Set <code>transpose = TRUE</code> when using <code>split_pref_suff()</code> in a <code><a href="https://dplyr.tidyverse.org/reference/mutate.html" class="external-link">dplyr::mutate()</a></code>
call in the context of a data frame.
Default is <code>FALSE</code>.</p></dd>


<dt id="arg-inf-notation">inf_notation<a class="anchor" aria-label="anchor" href="#arg-inf-notation"></a></dt>
<dd><p>A boolean that tells whether to infer notation for <code>x</code>.
Default is <code>TRUE</code>.
See <code><a href="infer_notation.html">infer_notation()</a></code> for details.</p></dd>


<dt id="arg-notation">notation<a class="anchor" aria-label="anchor" href="#arg-notation"></a></dt>
<dd><p>A notation vector generated by one of the <code>*_notation()</code> functions, such as
<code>notation_vec()</code>, <code>arrow_notation</code>, or <code>bracket_notation</code>.</p></dd>


<dt id="arg-choose-most-specific">choose_most_specific<a class="anchor" aria-label="anchor" href="#arg-choose-most-specific"></a></dt>
<dd><p>A boolean that tells whether to choose the most specific
notation from the <code>notation</code> argument when the <code>notation</code> argument is a list.</p></dd>


<dt id="arg-ps">ps<a class="anchor" aria-label="anchor" href="#arg-ps"></a></dt>
<dd><p>A list of prefixes and suffixes in which each item of the list is itself a list with two items named <code>pref</code> and <code>suff</code>.</p></dd>


<dt id="arg-pref">pref<a class="anchor" aria-label="anchor" href="#arg-pref"></a></dt>
<dd><p>A string or list of strings that are prefixes. Default is <code>NULL</code>.</p></dd>


<dt id="arg-suff">suff<a class="anchor" aria-label="anchor" href="#arg-suff"></a></dt>
<dd><p>A string of list of strings that are suffixes. Default is <code>NULL</code>.</p></dd>


<dt id="arg-squish">squish<a class="anchor" aria-label="anchor" href="#arg-squish"></a></dt>
<dd><p>A boolean that tells whether to remove extra spaces in the output of <code>paste_*()</code> functions.
Default is <code>TRUE</code>.</p></dd>


<dt id="arg-which">which<a class="anchor" aria-label="anchor" href="#arg-which"></a></dt>
<dd><p>Tells which to keep, the prefix ("pref") or the suffix ("suff").</p></dd>


<dt id="arg-from">from<a class="anchor" aria-label="anchor" href="#arg-from"></a></dt>
<dd><p>The <code>notation</code> to switch <em>away from</em>.</p></dd>


<dt id="arg-to">to<a class="anchor" aria-label="anchor" href="#arg-to"></a></dt>
<dd><p>The <code>notation</code> to switch <em>to</em>.</p></dd>


<dt id="arg-flip">flip<a class="anchor" aria-label="anchor" href="#arg-flip"></a></dt>
<dd><p>A boolean that tells whether to also flip the notation. Default is <code>FALSE</code>.</p></dd>

</dl></div>
    <div class="section level2">
    <h2 id="value">Value<a class="anchor" aria-label="anchor" href="#value"></a></h2>
    <p>For <code>notation_vec()</code>, <code>arrow_notation</code>, and <code>bracket_notation</code>,
a string vector with named items <code>pref_start</code>, <code>pref_end</code>, <code>suff_start</code>, and <code>suff_end</code>;
For <code>split_pref_suff()</code>, a string list with named items <code>pref</code> and <code>suff</code>.
For <code>paste_pref_suff()</code>, <code>split_pref_suff()</code>, and <code>switch_notation()</code>,
a string list in notation format specified by various <code>notation</code> arguments, including
<code>from</code>, and <code>to</code>.
For <code>keep_pref_suff</code>, one of the prefix or suffix or a list of prefixes or suffixes.</p>
    </div>

    <div class="section level2">
    <h2 id="ref-examples">Examples<a class="anchor" aria-label="anchor" href="#ref-examples"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span><span class="fu">notation_vec</span><span class="op">(</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> pref_start   pref_end suff_start   suff_end </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         ""     " -&gt; "     " -&gt; "         "" </span>
<span class="r-in"><span><span class="va">arrow_notation</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> pref_start   pref_end suff_start   suff_end </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         ""     " -&gt; "     " -&gt; "         "" </span>
<span class="r-in"><span><span class="va">bracket_notation</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> pref_start   pref_end suff_start   suff_end </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         ""       " ["       " ["        "]" </span>
<span class="r-in"><span><span class="fu">split_pref_suff</span><span class="op">(</span><span class="st">"a -&gt; b"</span>, notation <span class="op">=</span> <span class="va">arrow_notation</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $pref</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "a"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $suff</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "b"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span><span class="co"># Or infer the notation (by default from notations_list)</span></span></span>
<span class="r-in"><span><span class="fu">split_pref_suff</span><span class="op">(</span><span class="st">"a -&gt; b"</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $pref</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "a"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $suff</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "b"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span><span class="fu">split_pref_suff</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"a -&gt; b"</span>, <span class="st">"c -&gt; d"</span>, <span class="st">"e -&gt; f"</span><span class="op">)</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $pref</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "a" "c" "e"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> $suff</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "b" "d" "f"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span><span class="fu">split_pref_suff</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"a -&gt; b"</span>, <span class="st">"c -&gt; d"</span>, <span class="st">"e -&gt; f"</span><span class="op">)</span>, transpose <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [[1]]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [[1]]$pref</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "a"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [[1]]$suff</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "b"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [[2]]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [[2]]$pref</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "c"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [[2]]$suff</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "d"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [[3]]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [[3]]$pref</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "e"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [[3]]$suff</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "f"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span><span class="fu">flip_pref_suff</span><span class="op">(</span><span class="st">"a [b]"</span>, notation <span class="op">=</span> <span class="va">bracket_notation</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "b [a]"</span>
<span class="r-in"><span><span class="co"># Infer notation</span></span></span>
<span class="r-in"><span><span class="fu">flip_pref_suff</span><span class="op">(</span><span class="st">"a [b]"</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "b [a]"</span>
<span class="r-in"><span><span class="fu">get_pref_suff</span><span class="op">(</span><span class="st">"a -&gt; b"</span>, which <span class="op">=</span> <span class="st">"suff"</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> suff </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  "b" </span>
<span class="r-in"><span><span class="fu">switch_notation</span><span class="op">(</span><span class="st">"a -&gt; b"</span>, from <span class="op">=</span> <span class="va">arrow_notation</span>, to <span class="op">=</span> <span class="va">bracket_notation</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "a [b]"</span>
<span class="r-in"><span><span class="co"># Infer notation and flip prefix and suffix</span></span></span>
<span class="r-in"><span><span class="fu">switch_notation</span><span class="op">(</span><span class="st">"a -&gt; b"</span>, to <span class="op">=</span> <span class="va">bracket_notation</span>, flip <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "b [a]"</span>
<span class="r-in"><span><span class="co"># Also works for vectors</span></span></span>
<span class="r-in"><span><span class="fu">switch_notation</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"a -&gt; b"</span>, <span class="st">"c -&gt; d"</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>                from <span class="op">=</span> <span class="va">arrow_notation</span>,</span></span>
<span class="r-in"><span>                to <span class="op">=</span> <span class="va">bracket_notation</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [[1]]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "a [b]"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [[2]]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "c [d]"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span><span class="co"># Functions can infer the correct notation and return multiple matches</span></span></span>
<span class="r-in"><span><span class="fu"><a href="infer_notation.html">infer_notation</a></span><span class="op">(</span><span class="st">"a [to b]"</span>,</span></span>
<span class="r-in"><span>               allow_multiple <span class="op">=</span> <span class="cn">TRUE</span>,</span></span>
<span class="r-in"><span>               choose_most_specific <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [[1]]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> pref_start   pref_end suff_start   suff_end </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         ""       " ["       " ["        "]" </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [[2]]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> pref_start   pref_end suff_start   suff_end </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         ""    " [to "    " [to "        "]" </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span><span class="co"># Or choose the most specific notation</span></span></span>
<span class="r-in"><span><span class="fu"><a href="infer_notation.html">infer_notation</a></span><span class="op">(</span><span class="st">"a [to b]"</span>,</span></span>
<span class="r-in"><span>               allow_multiple <span class="op">=</span> <span class="cn">TRUE</span>,</span></span>
<span class="r-in"><span>               choose_most_specific <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> pref_start   pref_end suff_start   suff_end </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         ""    " [to "    " [to "        "]" </span>
<span class="r-in"><span><span class="co"># When setting the from notation, only that type of notation will be switched</span></span></span>
<span class="r-in"><span><span class="fu">switch_notation</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"a -&gt; b"</span>, <span class="st">"c [to d]"</span><span class="op">)</span>,</span></span>
<span class="r-in"><span>                from <span class="op">=</span> <span class="va">arrow_notation</span>,</span></span>
<span class="r-in"><span>                to <span class="op">=</span> <span class="va">bracket_notation</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [[1]]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "a [b]"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [[2]]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "c [to d]"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span><span class="co"># But if notations are inferred, all notations can be switched</span></span></span>
<span class="r-in"><span><span class="fu">switch_notation</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"a -&gt; b"</span>, <span class="st">"c [to d]"</span><span class="op">)</span>, to <span class="op">=</span> <span class="va">bracket_notation</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [[1]]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "a [b]"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [[2]]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "c [d]"</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span><span class="co"># A double-switch can be accomplished.</span></span></span>
<span class="r-in"><span><span class="co"># In this first example, `RCLabels::first_dot_notation` is inferred.</span></span></span>
<span class="r-in"><span><span class="fu">switch_notation</span><span class="op">(</span><span class="st">"a.b.c"</span>, to <span class="op">=</span> <span class="va">arrow_notation</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "a -&gt; b.c"</span>
<span class="r-in"><span><span class="co"># In this second example,</span></span></span>
<span class="r-in"><span><span class="co"># it is easier to specify the `from` and `to` notations.</span></span></span>
<span class="r-in"><span><span class="fu">switch_notation</span><span class="op">(</span><span class="st">"a.b.c"</span>, to <span class="op">=</span> <span class="va">arrow_notation</span><span class="op">)</span> <span class="op"><a href="pipe.html">%&gt;%</a></span></span></span>
<span class="r-in"><span>  <span class="fu">switch_notation</span><span class="op">(</span>from <span class="op">=</span> <span class="va">first_dot_notation</span>, to <span class="op">=</span> <span class="va">arrow_notation</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "a -&gt; b -&gt; c"</span>
<span class="r-in"><span><span class="co"># "" can be used as an input</span></span></span>
<span class="r-in"><span><span class="fu">paste_pref_suff</span><span class="op">(</span>pref <span class="op">=</span> <span class="st">"a"</span>, suff <span class="op">=</span> <span class="st">""</span>, notation <span class="op">=</span> <span class="fu">RCLabels</span><span class="fu">::</span><span class="va"><a href="from_notation.html">from_notation</a></span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] "a [from ]"</span>
</code></pre></div>
    </div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p>Developed by Matthew Heun.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.2.</p>
</div>

    </footer></div>





  </body></html>

