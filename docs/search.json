[{"path":[]},{"path":"https://matthewheun.github.io/RCLabels/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"https://matthewheun.github.io/RCLabels/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"https://matthewheun.github.io/RCLabels/CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"https://matthewheun.github.io/RCLabels/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"https://matthewheun.github.io/RCLabels/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement matthew.heun@.com. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"https://matthewheun.github.io/RCLabels/CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"https://matthewheun.github.io/RCLabels/CODE_OF_CONDUCT.html","id":"id_1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"https://matthewheun.github.io/RCLabels/CODE_OF_CONDUCT.html","id":"id_2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"https://matthewheun.github.io/RCLabels/CODE_OF_CONDUCT.html","id":"id_3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"https://matthewheun.github.io/RCLabels/CODE_OF_CONDUCT.html","id":"id_4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"https://matthewheun.github.io/RCLabels/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.1, available https://www.contributor-covenant.org/version/2/1/code_of_conduct.html. Community Impact Guidelines inspired Mozilla’s code conduct enforcement ladder. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https://www.contributor-covenant.org/translations.","code":""},{"path":"https://matthewheun.github.io/RCLabels/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing to RCLabels","title":"Contributing to RCLabels","text":"document outlines propose change RCLabels package.","code":""},{"path":"https://matthewheun.github.io/RCLabels/CONTRIBUTING.html","id":"fixing-typos","dir":"","previous_headings":"","what":"Fixing typos","title":"Contributing to RCLabels","text":"can fix typos, spelling mistakes, grammatical errors documentation directly using GitHub web interface, long changes made source file. generally means ’ll need edit roxygen2 comments .R, .Rd file. can find .R file generates .Rd reading comment first line.","code":""},{"path":"https://matthewheun.github.io/RCLabels/CONTRIBUTING.html","id":"bigger-changes","dir":"","previous_headings":"","what":"Bigger changes","title":"Contributing to RCLabels","text":"want make change bigger fixing typos, first file issue GitHub make sure someone team agrees proposed change needed. ’ve found bug, please file issue illustrates bug minimal reprex.","code":""},{"path":"https://matthewheun.github.io/RCLabels/CONTRIBUTING.html","id":"pull-request-process","dir":"","previous_headings":"Bigger changes","what":"Pull request process","title":"Contributing to RCLabels","text":"Fork package clone onto computer. Install development dependencies devtools::install_dev_deps(), make sure package passes R CMD check running devtools::check(). R CMD check doesn’t pass cleanly, ’s good idea ask help continuing. Create Git branch pull request (PR). recommend using usethis::pr_init(\"brief-description--change\"). Make changes, commit git, create PR running usethis::pr_push(). Follow prompts browser. title PR briefly describe change. body PR contain Fixes #issue-number. user-facing changes, add bullet top NEWS.md (.e., beneath “always resolves latest release.”).","code":""},{"path":"https://matthewheun.github.io/RCLabels/CONTRIBUTING.html","id":"code-style","dir":"","previous_headings":"Bigger changes","what":"Code style","title":"Contributing to RCLabels","text":"New code written style matches rest code RCLabels. use roxygen2, Markdown syntax, documentation.","code":""},{"path":"https://matthewheun.github.io/RCLabels/CONTRIBUTING.html","id":"tests","dir":"","previous_headings":"Bigger changes","what":"Tests","title":"Contributing to RCLabels","text":"use testthat unit tests. maintain 100% test coverage. Contributions reduce test coverage less 100% rejected.","code":""},{"path":"https://matthewheun.github.io/RCLabels/CONTRIBUTING.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"Contributing to RCLabels","text":"Please note RCLabels project released Contributor Code Conduct. contributing project agree abide terms.","code":""},{"path":"https://matthewheun.github.io/RCLabels/CONTRIBUTING.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributing to RCLabels","text":"guide contributing adapted Contributing guide usethis package.","code":""},{"path":"https://matthewheun.github.io/RCLabels/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 RCLabels authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://matthewheun.github.io/RCLabels/articles/RCLabels.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"RCLabels","text":"Working matrices often requires manipulating row column labels achieve desired outcomes matrix mathematics. RCLabels package (Row Column Labels) provides convenient tools manipulating labels.","code":""},{"path":"https://matthewheun.github.io/RCLabels/articles/RCLabels.html","id":"use-cases","dir":"Articles","previous_headings":"","what":"Use cases","title":"RCLabels","text":"Two applications matrix mathematics input-output analysis economics physical supply-use table (PSUT) matrices energy conversion chain (ECC) analysis. contexts, row column labels describe processing stages flows goods services processing stages. Row column labels can benefit applications, ensuring like quantities added, subtracted, multiplied, divided, etc., provided row column labels respected matrix operations. One package respects row column labels matsbyname, thereby making economic ECC input-output analyses easier. Easy manipulation row column labels , therefore, enabling capability using matsbyname package. package (RCLabels) provides easy manipulation row column labels. fact, matsbyname package uses RCLabels functions internally.","code":""},{"path":"https://matthewheun.github.io/RCLabels/articles/RCLabels.html","id":"label-structure","dir":"Articles","previous_headings":"","what":"Label structure","title":"RCLabels","text":"Row column labels always character strings, often prefix–suffix structure, prefix suffix denoted separator delimited ways. Example row column labels include “pref -> suff” (separator “->”) “pref [suff]” (suffix delimited “ [” “]”) “(pref) (suff)” (prefix suffix surrounded “(” “)”) “pref.suff” (separator “.”) Prefixes usually “thing” interest, e.g. energy carrier (“Coal”) processing stage energy conversion chain (“Main activity producer electricity plants”). Suffixes usually modifiers metadata thing (prefix). Suffixes can describe destination energy carrier (“Light [-> Industry USA]”). Suffixes can describe output processing stage (“Production [Coal ZAR]”).","code":""},{"path":"https://matthewheun.github.io/RCLabels/articles/RCLabels.html","id":"working-with-row-and-column-labels","dir":"Articles","previous_headings":"","what":"Working with row and column labels","title":"RCLabels","text":"RCLabels package streamlines working row column labels.","code":""},{"path":"https://matthewheun.github.io/RCLabels/articles/RCLabels.html","id":"notation","dir":"Articles","previous_headings":"Working with row and column labels","what":"Notation","title":"RCLabels","text":"RCLabels enables creation notation objects describe structure row column label via notation_vec() function. Several notation objects provided convenience within RCLabels. Note identical pref_end suff_start values (shown notations ) interpreted single delimiter throughout RCLables package. Empty strings (\"\") mean indication given start end prefix suffix.","code":"# Create a notation object. my_notation <- notation_vec(pref_start = \"(\", pref_end = \") \",                             suff_start = \"[\", suff_end = \"]\")  # Notation objects are character vectors. my_notation #> pref_start   pref_end suff_start   suff_end  #>        \"(\"       \") \"        \"[\"        \"]\" arrow_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"     \" -> \"     \" -> \"         \"\" paren_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"       \" (\"       \" (\"        \")\" bracket_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"       \" [\"       \" [\"        \"]\" first_dot_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"        \".\"        \".\"         \"\" from_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"  \" [from \"  \" [from \"        \"]\" of_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"    \" [of \"    \" [of \"        \"]\" to_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"    \" [to \"    \" [to \"        \"]\" bracket_arrow_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"    \" [-> \"    \" [-> \"        \"]\""},{"path":"https://matthewheun.github.io/RCLabels/articles/RCLabels.html","id":"creating-row-and-column-labels","dir":"Articles","previous_headings":"Working with row and column labels","what":"Creating row and column labels","title":"RCLabels","text":"Row column labels can created paste_pref_suff() function","code":"my_label <- paste_pref_suff(pref = \"Coal\", suff = \"from Coal mines in USA\",                              notation = my_notation) my_label #> [1] \"(Coal) [from Coal mines in USA]\""},{"path":"https://matthewheun.github.io/RCLabels/articles/RCLabels.html","id":"manipulating-row-and-column-labels-prefixes-and-suffixes","dir":"Articles","previous_headings":"Working with row and column labels","what":"Manipulating row and column labels (prefixes and suffixes)","title":"RCLabels","text":"Row column labels can manipulated using several helpful functions. prefix suffix can extracted row column label.","code":"# Split the prefix from the suffix to obtain a named list of strings. split_pref_suff(my_label, notation = my_notation) #> $pref #> [1] \"Coal\" #>  #> $suff #> [1] \"from Coal mines in USA\"  # Flip the prefix and suffix, maintaining the same notation. flip_pref_suff(my_label, notation = my_notation) #> [1] \"(from Coal mines in USA) [Coal]\"  # Change the notation. switch_notation(my_label, from = my_notation, to = paren_notation) #> [1] \"Coal (from Coal mines in USA)\"  # Change the notation and flip the prefix and suffix. switch_notation(my_label, from = my_notation, to = paren_notation, flip = TRUE) #> [1] \"from Coal mines in USA (Coal)\" get_pref_suff(my_label, which = \"pref\", notation = my_notation) #>   pref  #> \"Coal\" get_pref_suff(my_label, which = \"suff\", notation = my_notation) #>                     suff  #> \"from Coal mines in USA\""},{"path":"https://matthewheun.github.io/RCLabels/articles/RCLabels.html","id":"vectors-and-lists-of-row-and-column-labels","dir":"Articles","previous_headings":"Working with row and column labels","what":"Vectors and lists of row and column labels","title":"RCLabels","text":"functions RCLabels work vectors lists row column labels. feature means functions RCLabels can used data frames. Note transpose = TRUE ensures single list column created.","code":"labels <- c(\"a [of b in c]\", \"d [of e in f]\", \"g [of h in i]\") labels #> [1] \"a [of b in c]\" \"d [of e in f]\" \"g [of h in i]\"  split_pref_suff(labels, notation = bracket_notation) #> $pref #> [1] \"a\" \"d\" \"g\" #>  #> $suff #> [1] \"of b in c\" \"of e in f\" \"of h in i\" labels #> [1] \"a [of b in c]\" \"d [of e in f]\" \"g [of h in i]\"  df <- tibble::tibble(labels = labels) result <- df %>%    dplyr::mutate(     split = split_pref_suff(labels, notation = bracket_notation, transpose = TRUE)   ) result$split[[1]] #> $pref #> [1] \"a\" #>  #> $suff #> [1] \"of b in c\" result$split[[2]] #> $pref #> [1] \"d\" #>  #> $suff #> [1] \"of e in f\" result$split[[3]] #> $pref #> [1] \"g\" #>  #> $suff #> [1] \"of h in i\""},{"path":"https://matthewheun.github.io/RCLabels/articles/RCLabels.html","id":"nouns-and-prepositions","dir":"Articles","previous_headings":"","what":"Nouns and prepositions","title":"RCLabels","text":"discussed , prefix often “thing” interest, remainder label (suffix) modifies prefix. use case common introduce additional terms enable additional functionality. prefix usually noun (one words), suffix usually consists prepositional phrases (consisting preposition object). RCLabels includes list common prepositions.","code":"prepositions_list #> [1] \"in\"   \"into\" \"from\" \"of\"   \"->\"   \"to\""},{"path":"https://matthewheun.github.io/RCLabels/articles/RCLabels.html","id":"working-with-row-and-column-labels-nouns-and-prepositions","dir":"Articles","previous_headings":"","what":"Working with row and column labels (nouns and prepositions)","title":"RCLabels","text":"RCLabels supports “nouns prepositions” view row column labels several functions. get_nouns() extracts nouns row column label. Labels can split component pieces.","code":"labels #> [1] \"a [of b in c]\" \"d [of e in f]\" \"g [of h in i]\"  # Extract the nouns. get_nouns(labels, notation = bracket_notation) #> noun noun noun  #>  \"a\"  \"d\"  \"g\"  # Extract the prepositional phrases. get_pps(labels, notation = bracket_notation) #>         pps         pps         pps  #> \"of b in c\" \"of e in f\" \"of h in i\"  # Extract the prepositions themselves. get_prepositions(labels, notation = bracket_notation) #> $prepositions #> [1] \"of\" \"in\" #>  #> $prepositions #> [1] \"of\" \"in\" #>  #> $prepositions #> [1] \"of\" \"in\"  # Extract the objects of the prepositions. # Objects are named by the preposition of their phrase. get_objects(labels, notation = bracket_notation) #> $objects #>  of  in  #> \"b\" \"c\"  #>  #> $objects #>  of  in  #> \"e\" \"f\"  #>  #> $objects #>  of  in  #> \"h\" \"i\"  # The get_piece() function is a convenience function # that extracts just what you want. get_piece(labels, piece = \"noun\", notation = bracket_notation) #> noun noun noun  #>  \"a\"  \"d\"  \"g\" get_piece(labels, piece = \"pref\") #> pref pref pref  #>  \"a\"  \"d\"  \"g\" get_piece(labels, piece = \"suff\") #>        suff        suff        suff  #> \"of b in c\" \"of e in f\" \"of h in i\" get_piece(labels, piece = \"of\") #> [[1]] #>  of  #> \"b\"  #>  #> [[2]] #>  of  #> \"e\"  #>  #> [[3]] #>  of  #> \"h\" get_piece(labels, piece = \"in\") #> [[1]] #>  in  #> \"c\"  #>  #> [[2]] #>  in  #> \"f\"  #>  #> [[3]] #>  in  #> \"i\" # An empty string is returned when the preposition is missing. get_piece(labels, piece = \"bogus\") #> [[1]] #> bogus  #>    \"\"  #>  #> [[2]] #> bogus  #>    \"\"  #>  #> [[3]] #> bogus  #>    \"\" labels #> [1] \"a [of b in c]\" \"d [of e in f]\" \"g [of h in i]\" # Split the labels into pieces, named by \"noun\" and prepositions. split_labels <- split_noun_pp(labels,                               prepositions = prepositions_list,                               notation = bracket_notation) split_labels #> [[1]] #> noun   of   in  #>  \"a\"  \"b\"  \"c\"  #>  #> [[2]] #> noun   of   in  #>  \"d\"  \"e\"  \"f\"  #>  #> [[3]] #> noun   of   in  #>  \"g\"  \"h\"  \"i\"  # Recombine split labels. paste_noun_pp(split_labels, notation = bracket_notation) #> [1] \"a [of b in c]\" \"d [of e in f]\" \"g [of h in i]\"  # Recombine with a new notation. paste_noun_pp(split_labels, notation = paren_notation) #> [1] \"a (of b in c)\" \"d (of e in f)\" \"g (of h in i)\""},{"path":"https://matthewheun.github.io/RCLabels/articles/RCLabels.html","id":"modifying-row-and-column-labels","dir":"Articles","previous_headings":"","what":"Modifying row and column labels","title":"RCLabels","text":"modify row column labels, use one modify_* functions. modify pieces labels, use modify_label_pieces() function. modify_label_pieces() enables assigning new values using “one--many” approach enables aggregation. eliminate piece label altogether, use remove_label_pieces() function. much power comes much responsibility!","code":"labels #> [1] \"a [of b in c]\" \"d [of e in f]\" \"g [of h in i]\"  # Set new values for nouns. modify_nouns(labels,               new_nouns = c(\"Coal\", \"Oil\", \"Natural gas\"),               notation = bracket_notation) #> [1] \"Coal [of b in c]\"        \"Oil [of e in f]\"         #> [3] \"Natural gas [of h in i]\" labels #> [1] \"a [of b in c]\" \"d [of e in f]\" \"g [of h in i]\"  # Change nouns in several labels to \"Production\" and \"Manufacture\", # as indicated by the modification map. modify_label_pieces(labels,                      piece = \"noun\",                      mod_map = list(Production = c(\"a\", \"b\", \"c\", \"d\"),                                    Manufacture = c(\"g\", \"h\", \"i\", \"j\")),                      notation = bracket_notation) #> [1] \"Production [of b in c]\"  \"Production [of e in f]\"  #> [3] \"Manufacture [of h in i]\"  # Change the objects of the \"in\" preposition,  # according to the modification map. modify_label_pieces(labels,                      piece = \"in\",                      mod_map = list(GHA = \"c\", ZAF = c(\"f\", \"i\")),                      notation = bracket_notation) #> [1] \"a [of b in GHA]\" \"d [of e in ZAF]\" \"g [of h in ZAF]\"  # Change the objects of \"of\" prepositions, # according to the modification map. modify_label_pieces(labels,                      piece = \"of\",                      mod_map = list(Coal = \"b\", `Crude oil` = c(\"e\", \"h\")),                      notation = bracket_notation) #> [1] \"a [of Coal in c]\"      \"d [of Crude oil in f]\" \"g [of Crude oil in i]\" labels #> [1] \"a [of b in c]\" \"d [of e in f]\" \"g [of h in i]\"  # Eliminate all of the prepositional phrases that begin with \"in\". remove_label_pieces(labels,                      piece = \"in\",                      notation = bracket_notation) #> [1] \"a [of b]\" \"d [of e]\" \"g [of h]\"  # Eliminate all of the prepositional phrases that begin with \"of\" and \"in\". # Note that some spaces remain. remove_label_pieces(labels,                      piece = c(\"of\", \"in\"),                      notation = bracket_notation) #> [1] \"a [ ]\" \"d [ ]\" \"g [ ]\""},{"path":"https://matthewheun.github.io/RCLabels/articles/RCLabels.html","id":"detecting-strings-in-labels","dir":"Articles","previous_headings":"","what":"Detecting strings in labels","title":"RCLabels","text":"times helpful know string label. match_by_pattern() searches matches row column labels regular expression. Internally, match_by_pattern() uses grepl() regular expression matching.","code":"labels <- c(\"Production [of b in c]\", \"d [of Coal in f]\", \"g [of h in USA]\")  # With default `pieces` argument, matching is done for whole labels. match_by_pattern(labels, regex_pattern = \"Production\") #> [1]  TRUE FALSE FALSE match_by_pattern(labels, regex_pattern = \"Coal\") #> [1] FALSE  TRUE FALSE match_by_pattern(labels, regex_pattern = \"USA\") #> [1] FALSE FALSE  TRUE  # Check beginnings of labels: match! match_by_pattern(labels, regex_pattern = \"^Production\") #> [1]  TRUE FALSE FALSE # Check at ends of labels: no match! match_by_pattern(labels, regex_pattern = \"Production$\") #> [1] FALSE FALSE FALSE  # Search by prefix or suffix. match_by_pattern(labels, regex_pattern = \"Production\", pieces = \"pref\") #> [1]  TRUE FALSE FALSE match_by_pattern(labels, regex_pattern = \"Production\", pieces = \"suff\") #> [1] FALSE FALSE FALSE # When pieces is \"pref\" or \"suff\", only one can be specified. # The following function call gives an error. # match_by_pattern(labels, regex_pattern = \"Production\", pieces = c(\"pref\", \"to\"))  # Search by noun or preposition. match_by_pattern(labels, regex_pattern = \"Production\", pieces = \"noun\") #> [1]  TRUE FALSE FALSE match_by_pattern(labels, regex_pattern = \"Production\", pieces = \"in\") #> [1] FALSE FALSE FALSE # Searching can be done with complicated regex patterns. match_by_pattern(labels,                   regex_pattern = make_or_pattern(c(\"c\", \"f\")),                  pieces = \"in\") #> [1]  TRUE  TRUE FALSE match_by_pattern(labels,                  regex_pattern = make_or_pattern(c(\"b\", \"Coal\", \"USA\")),                  pieces = \"in\") #> [1] FALSE FALSE  TRUE match_by_pattern(labels,                  regex_pattern = make_or_pattern(c(\"b\", \"Coal\", \"USA\")),                  pieces = c(\"of\", \"in\")) #> [1] TRUE TRUE TRUE # Works with custom lists of prepositions. match_by_pattern(labels,                  regex_pattern = make_or_pattern(c(\"b\", \"Coal\", \"GBR\", \"USA\")),                  pieces = c(\"noun\", \"of\", \"in\", \"to\"),                  prepositions = c(\"of\", \"to\", \"in\")) #> [1] TRUE TRUE TRUE"},{"path":"https://matthewheun.github.io/RCLabels/articles/RCLabels.html","id":"replacing-strings-in-labels","dir":"Articles","previous_headings":"","what":"Replacing strings in labels","title":"RCLabels","text":"times helpful replace strings labels. replace_by_pattern() function replace strings row column labels regular expression pattern. Note replace_by_pattern() similar match_by_pattern(), except replace_by_pattern() additional argument, replacement. Internally, replace_by_pattern() uses gsub() perform regular expression matching.","code":"labels <- c(\"Production [of b in c]\", \"d [of Coal in f]\", \"g [of h in USA]\") labels #> [1] \"Production [of b in c]\" \"d [of Coal in f]\"       \"g [of h in USA]\"  # If `pieces = \"all\"` (the default), the entire label is available for replacements. replace_by_pattern(labels,                    regex_pattern = \"Production\",                    replacement = \"Manufacture\") #> [1] \"Manufacture [of b in c]\" \"d [of Coal in f]\"        #> [3] \"g [of h in USA]\" replace_by_pattern(labels,                    regex_pattern = \"Coal\",                    replacement = \"Oil\") #> [1] \"Production [of b in c]\" \"d [of Oil in f]\"        \"g [of h in USA]\" replace_by_pattern(labels,                    regex_pattern = \"USA\",                    replacement = \"GHA\") #> [1] \"Production [of b in c]\" \"d [of Coal in f]\"       \"g [of h in GHA]\"  # Replace by prefix and suffix. replace_by_pattern(labels,                    regex_pattern = \"Production\",                    replacement = \"Manufacture\",                    pieces = \"pref\") #> [1] \"Manufacture [of b in c]\" \"d [of Coal in f]\"        #> [3] \"g [of h in USA]\" replace_by_pattern(labels,                    regex_pattern = \"Coa\",                    replacement = \"Bow\",                    pieces = \"suff\") #> [1] \"Production [of b in c]\" \"d [of Bowl in f]\"       \"g [of h in USA]\" # Nothing should change, because USA is in the suffix. replace_by_pattern(labels,                    regex_pattern = \"SA\",                    replacement = \"SSR\",                    pieces = \"pref\") #> [1] \"Production [of b in c]\" \"d [of Coal in f]\"       \"g [of h in USA]\" # Now USA --> USSR, because USA is in the suffix. replace_by_pattern(labels,                    regex_pattern = \"SA\",                    replacement = \"SSR\",                    pieces = \"suff\") #> [1] \"Production [of b in c]\" \"d [of Coal in f]\"       \"g [of h in USSR]\" # This will throw an error, because only \"pref\" or \"suff\" can be specified. # replace_by_pattern(labels, #                    regex_pattern = \"SA\", #                    replacement = \"SSR\", #                    pieces = c(\"pref\", \"suff\")  # Replace by noun or preposition. replace_by_pattern(labels,                    regex_pattern = \"Production\",                    replacement = \"Manufacture\",                    pieces = \"noun\") #> [1] \"Manufacture [of b in c]\" \"d [of Coal in f]\"        #> [3] \"g [of h in USA]\" replace_by_pattern(labels,                    regex_pattern = \"^Pro\",                    replacement = \"Con\",                    pieces = \"noun\") #> [1] \"Conduction [of b in c]\" \"d [of Coal in f]\"       \"g [of h in USA]\" # Won't match: wrong side of string. replace_by_pattern(labels,                    regex_pattern = \"Pro$\",                    replacement = \"Con\",                    pieces = \"noun\") #> [1] \"Production [of b in c]\" \"d [of Coal in f]\"       \"g [of h in USA]\" # No change, because \"Production\" is a noun. replace_by_pattern(labels,                    regex_pattern = \"Production\",                    replacement = \"Manufacture\",                    pieces = \"of\") #> [1] \"Production [of b in c]\" \"d [of Coal in f]\"       \"g [of h in USA]\" # Now try with \"of\". replace_by_pattern(labels,                    regex_pattern = \"Coal\",                    replacement = \"Oil\",                    pieces = \"of\") #> [1] \"Production [of b in c]\" \"d [of Oil in f]\"        \"g [of h in USA]\" # No change, because \"Coal\" is not \"in\" anything. replace_by_pattern(labels,                    regex_pattern = \"Coal\",                    replacement = \"Oil\",                    pieces = \"in\") #> [1] \"Production [of b in c]\" \"d [of Coal in f]\"       \"g [of h in USA]\" # Now try in \"in\". replace_by_pattern(labels,                    regex_pattern = \"USA\",                    replacement = \"GBR\",                    pieces = \"in\") #> [1] \"Production [of b in c]\" \"d [of Coal in f]\"       \"g [of h in GBR]\" replace_by_pattern(labels,                    regex_pattern = \"A$\",                    replacement = \"upercalifragilisticexpialidocious\",                    pieces = \"in\") #> [1] \"Production [of b in c]\"                          #> [2] \"d [of Coal in f]\"                                #> [3] \"g [of h in USupercalifragilisticexpialidocious]\""},{"path":"https://matthewheun.github.io/RCLabels/articles/RCLabels.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"RCLabels","text":"RCLabels package streamlines manipulation row column labels matrices. Applications include input-output analysis economics energy conversion chain analysis anywhere row column labels important matrix mathematics.","code":""},{"path":"https://matthewheun.github.io/RCLabels/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Matthew Heun. Author, maintainer.","code":""},{"path":"https://matthewheun.github.io/RCLabels/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Matthew Kuperus Heun (2025). RCLabels: Tools munging manipulating row column labels matrices. R package version 0.1.12. https://doi.org/10.5281/zenodo.5819143","code":"@Manual{,   title = {RCLabels: Tools for munging and manipulating row and column labels on matrices},   author = {Matthew Kuperus Heun},   year = {2025},   note = {R package version 0.1.12},   url = {https://doi.org/10.5281/zenodo.5819143}, }"},{"path":[]},{"path":"https://matthewheun.github.io/RCLabels/index.html","id":"statement-of-need","dir":"","previous_headings":"","what":"Statement of need","title":"Manipulate Matrix Row and Column Labels with Ease","text":"analyzing lists matrices (whether actual lists matrix columns matsindf data frame), can challenging operate matrix row column names. package provides functions assist manipulating matrix row column labels situations. Example applications include economic energy conversion chain analyses using input-output (IO) analysis physical supply-use table (PSUT) analysis.","code":""},{"path":"https://matthewheun.github.io/RCLabels/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Manipulate Matrix Row and Column Labels with Ease","text":"can install RCLabels CRAN : can install development version RCLabels GitHub :","code":"install.packages(\"RCLabels\") # install.packages(\"devtools\") devtools::install_github(\"MatthewHeun/RCLabels\")"},{"path":"https://matthewheun.github.io/RCLabels/index.html","id":"more-information","dir":"","previous_headings":"","what":"More Information","title":"Manipulate Matrix Row and Column Labels with Ease","text":"Find information, including vignettes function documentation, https://MatthewHeun.github.io/RCLabels/.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/arrow_notation.html","id":null,"dir":"Reference","previous_headings":"","what":"Arrow notation — arrow_notation","title":"Arrow notation — arrow_notation","text":"description arrow notation.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/arrow_notation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Arrow notation — arrow_notation","text":"","code":"arrow_notation"},{"path":"https://matthewheun.github.io/RCLabels/reference/arrow_notation.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Arrow notation — arrow_notation","text":"vector notational symbols provides arrow separator (\"-> b\") prefix suffix.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/arrow_notation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Arrow notation — arrow_notation","text":"","code":"arrow_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"     \" -> \"     \" -> \"         \"\""},{"path":"https://matthewheun.github.io/RCLabels/reference/bracket_arrow_notation.html","id":null,"dir":"Reference","previous_headings":"","what":"Bracket arrow notation — bracket_arrow_notation","title":"Bracket arrow notation — bracket_arrow_notation","text":"description bracket arrow notation.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/bracket_arrow_notation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bracket arrow notation — bracket_arrow_notation","text":"","code":"bracket_arrow_notation"},{"path":"https://matthewheun.github.io/RCLabels/reference/bracket_arrow_notation.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Bracket arrow notation — bracket_arrow_notation","text":"vector notational symbols provides bracket arrow (\"[-> b]\") notation.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/bracket_arrow_notation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bracket arrow notation — bracket_arrow_notation","text":"","code":"bracket_arrow_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"    \" [-> \"    \" [-> \"        \"]\""},{"path":"https://matthewheun.github.io/RCLabels/reference/bracket_notation.html","id":null,"dir":"Reference","previous_headings":"","what":"Bracket notation — bracket_notation","title":"Bracket notation — bracket_notation","text":"description bracket notation.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/bracket_notation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bracket notation — bracket_notation","text":"","code":"bracket_notation"},{"path":"https://matthewheun.github.io/RCLabels/reference/bracket_notation.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Bracket notation — bracket_notation","text":"vector notational symbols provides bracket (\"[b]\") notation.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/bracket_notation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bracket notation — bracket_notation","text":"","code":"bracket_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"       \" [\"       \" [\"        \"]\""},{"path":"https://matthewheun.github.io/RCLabels/reference/dash_notation.html","id":null,"dir":"Reference","previous_headings":"","what":"A description of dash notation. — dash_notation","title":"A description of dash notation. — dash_notation","text":"description dash notation.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/dash_notation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A description of dash notation. — dash_notation","text":"","code":"dash_notation"},{"path":"https://matthewheun.github.io/RCLabels/reference/dash_notation.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A description of dash notation. — dash_notation","text":"vector notational symbols provides dash separator (\"- b\") prefix suffix.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/dash_notation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A description of dash notation. — dash_notation","text":"","code":"dash_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"      \" - \"      \" - \"         \"\""},{"path":"https://matthewheun.github.io/RCLabels/reference/first_dot_notation.html","id":null,"dir":"Reference","previous_headings":"","what":"First dot notation — first_dot_notation","title":"First dot notation — first_dot_notation","text":"description first dot notation. Note \".b.c\" splits prefix (\"\") suffix (\"b.c\").","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/first_dot_notation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"First dot notation — first_dot_notation","text":"","code":"first_dot_notation"},{"path":"https://matthewheun.github.io/RCLabels/reference/first_dot_notation.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"First dot notation — first_dot_notation","text":"vector notational symbols provides first dot (\".b\") notation.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/first_dot_notation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"First dot notation — first_dot_notation","text":"","code":"first_dot_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"        \".\"        \".\"         \"\""},{"path":"https://matthewheun.github.io/RCLabels/reference/from_notation.html","id":null,"dir":"Reference","previous_headings":"","what":"From notation — from_notation","title":"From notation — from_notation","text":"description notation.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/from_notation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"From notation — from_notation","text":"","code":"from_notation"},{"path":"https://matthewheun.github.io/RCLabels/reference/from_notation.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"From notation — from_notation","text":"vector notational symbols provides (\"[b]\") notation.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/from_notation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"From notation — from_notation","text":"","code":"from_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"  \" [from \"  \" [from \"        \"]\""},{"path":"https://matthewheun.github.io/RCLabels/reference/get_nouns.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract nouns from row and column labels — get_nouns","title":"Extract nouns from row and column labels — get_nouns","text":"Nouns first part row-column label, \"\" \"[b]\". Internally, function calls get_pref_suff(= \"pref\").","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/get_nouns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract nouns from row and column labels — get_nouns","text":"","code":"get_nouns(   labels,   inf_notation = TRUE,   notation = RCLabels::notations_list,   choose_most_specific = TRUE )"},{"path":"https://matthewheun.github.io/RCLabels/reference/get_nouns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract nouns from row and column labels — get_nouns","text":"labels list vector labels nouns extracted. inf_notation boolean tells whether infer notation x. Default TRUE. See infer_notation() details. notation notation type used extracting nouns. Default RCLabels::notations_list, meaning notation inferred using infer_notation(). choose_most_specific boolean tells whether choose specific notation notation inferring notation. Default TRUE.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/get_nouns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract nouns from row and column labels — get_nouns","text":"list nouns row column labels.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/get_nouns.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract nouns from row and column labels — get_nouns","text":"","code":"get_nouns(\"a [b]\", notation = bracket_notation) #> noun  #>  \"a\"  # Also works with vectors and lists. get_nouns(c(\"a [b]\", \"c [d]\")) #> noun noun  #>  \"a\"  \"c\"  get_nouns(list(\"a [b]\", \"c [d]\")) #> noun noun  #>  \"a\"  \"c\""},{"path":"https://matthewheun.github.io/RCLabels/reference/get_objects.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract objects of prepositional phrases in row and column labels — get_objects","title":"Extract objects of prepositional phrases in row and column labels — get_objects","text":"function extracts objects prepositional phrases row column labels. format output list named items, one name preposition encountered labels. Objects NA prepositional phrase starting preposition.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/get_objects.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract objects of prepositional phrases in row and column labels — get_objects","text":"","code":"get_objects(   labels,   inf_notation = TRUE,   notation = RCLabels::notations_list,   choose_most_specific = FALSE,   prepositions = RCLabels::prepositions_list )"},{"path":"https://matthewheun.github.io/RCLabels/reference/get_objects.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract objects of prepositional phrases in row and column labels — get_objects","text":"labels row column labels prepositional phrases extracted. inf_notation boolean tells whether infer notation x. Default TRUE. See infer_notation() details. notation notation type used extracting prepositions. Default RCLabels::notations_list, meaning notation inferred using infer_notation(). choose_most_specific boolean tells whether choose specific notation notation inferring notation. Default FALSE less specific notation can inferred. combination RCLabels::notations_list, default value FALSE means RCLabels::bracket_notation selected instead anything specific, RCLabels::from_notation. prepositions vector strings treated prepositions. Note space appended word internally, , e.g., \"\" becomes \"\". Default RCLabels::prepositions_list.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/get_objects.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract objects of prepositional phrases in row and column labels — get_objects","text":"list objects prepositional phrases, names prepositions, values objects.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/get_objects.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract objects of prepositional phrases in row and column labels — get_objects","text":"","code":"get_objects(c(\"a [of b into c]\", \"d [of Coal from e -> f]\")) #> $objects #>   of into  #>  \"b\"  \"c\"  #>  #> $objects #>       #> \"f]\"  #>"},{"path":"https://matthewheun.github.io/RCLabels/reference/get_piece.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a piece of a label — get_piece","title":"Get a piece of a label — get_piece","text":"wrapper function get_pref_suff(), get_nouns(), get_objects(). returns piece row column label.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/get_piece.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a piece of a label — get_piece","text":"","code":"get_piece(   labels,   piece = \"all\",   inf_notation = TRUE,   notation = RCLabels::notations_list,   choose_most_specific = FALSE,   prepositions = RCLabels::prepositions_list )"},{"path":"https://matthewheun.github.io/RCLabels/reference/get_piece.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a piece of a label — get_piece","text":"labels row column labels prepositional phrases extracted. piece name item return. inf_notation boolean tells whether infer notation x. Default TRUE. See infer_notation() details. notation notation type used extracting prepositions. Default RCLabels::notations_list, meaning notation inferred using infer_notation(). choose_most_specific boolean tells whether choose specific notation notation inferring notation. Default FALSE less specific notation can inferred. combination RCLabels::notations_list, default value FALSE means RCLabels::bracket_notation selected instead anything specific, RCLabels::from_notation. prepositions vector strings treated prepositions. Note space appended word internally, , e.g., \"\" becomes \"\". Default RCLabels::prepositions_list.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/get_piece.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a piece of a label — get_piece","text":"piece labels.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/get_piece.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get a piece of a label — get_piece","text":"piece typically one \"\" (returns labels directly), \"pref\" (prefixes), \"suff\" (suffixes), \"noun\" (returns noun), \"pps\" (prepositional phrases, returns prepositional phrases full), \"prepositions\" (returns list prepositions), \"objects\" (returns list objects prepositions names), preposition prepositions (string), return object preposition named preposition . piece must character vector length 1. piece missing label, \"\" (empty string) returned. specifying one notation, sure notations list. notation = c(RCLabels::bracket_notation, RCLabels::arrow_notation) unlikely produce desired result, notations concatenated together form long string vector. Rather say notation = list(RCLabels::bracket_notation, RCLabels::arrow_notation).","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/get_piece.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get a piece of a label — get_piece","text":"","code":"labs <- c(\"a [from b in c]\", \"d [of e in f]\", \"Export [of Coal from USA to MEX]\") get_piece(labs, \"pref\") #>     pref     pref     pref  #>      \"a\"      \"d\" \"Export\"  get_piece(labs, \"suff\") #>                      suff                      suff                      suff  #>             \"from b in c\"               \"of e in f\" \"of Coal from USA to MEX\"  get_piece(labs, piece = \"noun\") #>     noun     noun     noun  #>      \"a\"      \"d\" \"Export\"  get_piece(labs, piece = \"pps\") #>                       pps                       pps                       pps  #>             \"from b in c\"               \"of e in f\" \"of Coal from USA to MEX\"  get_piece(labs, piece = \"prepositions\") #> $prepositions #> [1] \"from\" \"in\"   #>  #> $prepositions #> [1] \"of\" \"in\" #>  #> $prepositions #> [1] \"of\"   \"from\" \"to\"   #>  get_piece(labs, piece = \"objects\") #> $objects #> from   in  #>  \"b\"  \"c\"  #>  #> $objects #>  of  in  #> \"e\" \"f\"  #>  #> $objects #>     of   from     to  #> \"Coal\"  \"USA\"  \"MEX\"  #>  get_piece(labs, piece = \"from\") #> [[1]] #> from  #>  \"b\"  #>  #> [[2]] #> from  #>   \"\"  #>  #> [[3]] #>  from  #> \"USA\"  #>  get_piece(labs, piece = \"in\") #> [[1]] #>  in  #> \"c\"  #>  #> [[2]] #>  in  #> \"f\"  #>  #> [[3]] #> in  #> \"\"  #>  get_piece(labs, piece = \"of\") #> [[1]] #> of  #> \"\"  #>  #> [[2]] #>  of  #> \"e\"  #>  #> [[3]] #>     of  #> \"Coal\"  #>  get_piece(labs, piece = \"to\") #> [[1]] #> to  #> \"\"  #>  #> [[2]] #> to  #> \"\"  #>  #> [[3]] #>    to  #> \"MEX\"  #>"},{"path":"https://matthewheun.github.io/RCLabels/reference/get_pps.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract prepositional phrases of row and column labels — get_pps","title":"Extract prepositional phrases of row and column labels — get_pps","text":"function extracts prepositional phrases suffixes row column labels form \"[preposition b]\", \"preposition b\" prepositional phrase.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/get_pps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract prepositional phrases of row and column labels — get_pps","text":"","code":"get_pps(   labels,   inf_notation = TRUE,   notation = RCLabels::notations_list,   choose_most_specific = FALSE,   prepositions = RCLabels::prepositions_list )"},{"path":"https://matthewheun.github.io/RCLabels/reference/get_pps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract prepositional phrases of row and column labels — get_pps","text":"labels list vector labels prepositional phrases extracted. inf_notation boolean tells whether infer notation x. Default TRUE. See infer_notation() details. notation notation type used extracting prepositional phrases. Default RCLabels::notations_list, meaning notation inferred using infer_notation(). choose_most_specific boolean tells whether choose specific notation notation inferring notation. Default FALSE less specific notation can inferred. combination RCLabels::notations_list, default value FALSE means RCLabels::bracket_notation selected instead anything specific, RCLabels::from_notation. prepositions list prepositions search. Default RCLabels::prepositions_list.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/get_pps.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract prepositional phrases of row and column labels — get_pps","text":"prepositional phrases suffix.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/get_pps.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract prepositional phrases of row and column labels — get_pps","text":"","code":"get_pps(c(\"a [in b]\", \"c [of d]\")) #>    pps    pps  #> \"in b\" \"of d\"  get_pps(c(\"a [of b in c]\", \"d [-> e of f]\")) #>         pps         pps  #> \"of b in c\" \"-> e of f\""},{"path":"https://matthewheun.github.io/RCLabels/reference/get_prepositions.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract prepositions from row and column labels — get_prepositions","title":"Extract prepositions from row and column labels — get_prepositions","text":"function extracts prepositions list row column labels. list outer structure number labels inner structure prepositional phrase specific label.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/get_prepositions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract prepositions from row and column labels — get_prepositions","text":"","code":"get_prepositions(   labels,   inf_notation = TRUE,   notation = RCLabels::notations_list,   choose_most_specific = FALSE,   prepositions = RCLabels::prepositions_list )"},{"path":"https://matthewheun.github.io/RCLabels/reference/get_prepositions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract prepositions from row and column labels — get_prepositions","text":"labels row column labels prepositional phrases extracted. inf_notation boolean tells whether infer notation x. Default TRUE. See infer_notation() details. notation notation type used extracting prepositions. Default RCLabels::notations_list, meaning notation inferred using infer_notation(). choose_most_specific boolean tells whether choose specific notation notation inferring notation. Default FALSE less specific notation can inferred. combination RCLabels::notations_list, default value FALSE means RCLabels::bracket_notation selected instead anything specific, RCLabels::from_notation. prepositions vector strings treated prepositions. Note space appended word internally, , e.g., \"\" becomes \"\". Default RCLabels::prepositions_list.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/get_prepositions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract prepositions from row and column labels — get_prepositions","text":"list prepositions.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/get_prepositions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract prepositions from row and column labels — get_prepositions","text":"labels form from_notation, to_notation similar, probably best give bracket_notation notation argument. Providing from_notation, to_notation similar notation argument lead empty results. preposition discarded extracting suffix, yielding empty strings prepositions.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/get_prepositions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract prepositions from row and column labels — get_prepositions","text":"","code":"get_prepositions(c(\"a [of b into c]\", \"d [-> e of f]\")) #> $prepositions #> [1] \"of\"   \"into\" #>  #> $prepositions #> [1] \"->\" \"of\" #>  get_prepositions(c(\"a [of b]\", \"d [-> e of f]\"),                  inf_notation = FALSE,                  notation = bracket_notation) #> $prepositions #> [1] \"of\" #>  #> $prepositions #> [1] \"->\" \"of\" #>  # Best to *not* specify notation by the preposition, # as the result will be empty strings. # Rather, give the notation as `bracket_notation` # as shown above, or infer the notation # as shown below. get_prepositions(c(\"a [of b]\", \"d [-> e of f]\"),                  inf_notation = TRUE) #> $prepositions #> [1] \"of\" #>  #> $prepositions #> [1] \"->\" \"of\" #>  # The suffix is extracted, and the preposition # is lost before looking for the preposition. get_prepositions(c(\"a [of b]\", \"d [of f]\"),                  inf_notation = FALSE,                  notation = of_notation) #> $prepositions #> [1] \"\" #>  #> $prepositions #> [1] \"\" #>"},{"path":"https://matthewheun.github.io/RCLabels/reference/in_notation.html","id":null,"dir":"Reference","previous_headings":"","what":"In notation — in_notation","title":"In notation — in_notation","text":"description notation.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/in_notation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"In notation — in_notation","text":"","code":"in_notation"},{"path":"https://matthewheun.github.io/RCLabels/reference/in_notation.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"In notation — in_notation","text":"vector notational symbols provides (\"[b]\") notation.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/in_notation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"In notation — in_notation","text":"","code":"in_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"    \" [in \"    \" [in \"        \"]\""},{"path":"https://matthewheun.github.io/RCLabels/reference/infer_notation.html","id":null,"dir":"Reference","previous_headings":"","what":"Infer the notation(s) for a row or column label — infer_notation","title":"Infer the notation(s) for a row or column label — infer_notation","text":"convenient know notation applicable row column labels. function infers notations appropriate x.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/infer_notation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Infer the notation(s) for a row or column label — infer_notation","text":"","code":"infer_notation(   x,   inf_notation = TRUE,   notations = RCLabels::notations_list,   allow_multiple = FALSE,   retain_names = FALSE,   choose_most_specific = TRUE,   must_succeed = TRUE )"},{"path":"https://matthewheun.github.io/RCLabels/reference/infer_notation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Infer the notation(s) for a row or column label — infer_notation","text":"x row column label (vector labels). inf_notation boolean tells whether infer notation x. Default TRUE. notations list notations matches inferred. function might work expected notation list. notation list, notations returned full. Default RCLabels::notations_list. allow_multiple boolean tells whether multiple notation matches allowed. FALSE (default), multiple matches give error. retain_names boolean tells whether retain names notations outgoing matches. Default FALSE. TRUE, return value always named list. one notations returned (example, choose_most_specific = TRUE), names never supplied. choose_most_specific boolean indicates whether -specific notation returned one notations matches x allow_multiple = FALSE. FALSE, first matching notation notations returned allow_multiple = FALSE. Default TRUE. See details. must_succeed boolean TRUE (default), causes error thrown matching notation found label x. FALSE, unsuccessful notation inference return NULL.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/infer_notation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Infer the notation(s) for a row or column label — infer_notation","text":"single notation object (x single row column label) list notation objects (x vector list). notations match x, NULL returned, either alone list.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/infer_notation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Infer the notation(s) for a row or column label — infer_notation","text":"function vectorized. Thus, x can vector, case output list notations. notations treated store matches label x can determined. notations named list notations. retain_names = TRUE, names notations retained, return value always list. default (allow_multiple = FALSE), single notation object returned item x one notation notations appropriate x. allow_multiple = FALSE (default) one notation applicable x, error thrown. Multiple matches can returned allow_multiple = TRUE. multiple notations matched, return value list. choose_most_specific = TRUE (default), specific notation notations returned. \"specific\" defined matching notation whose sum characters pref_start, pref_end, suff_start suff_end elements greatest. choose_most_specific = TRUE two matching notations notations number characters, first match returned. choose_most_specific = TRUE, value allow_multiple longer matters. allow_multiple = FALSE implied one notations returned. inf_notation = FALSE (default TRUE), notations returned unmodified, essentially disabling function. Although calling inf_notation = FALSE seems daft, behavior enables cleaner code elsewhere.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/infer_notation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Infer the notation(s) for a row or column label — infer_notation","text":"","code":"# Does not match any notations in RCLabels::notations_list # and throws an error, because the default value for `must_succeed` # is `TRUE`. if (FALSE) { # \\dontrun{ infer_notation(\"abc\") } # } # This returns `NULL`, because `must_succeed = FALSE`. infer_notation(\"abc\", must_succeed = FALSE) #> NULL # This succeeds, because the label is in the form of a # notation in `RCLabels::notation_list`, # the default value of the `notation` argument. infer_notation(\"a -> b\") #> pref_start   pref_end suff_start   suff_end  #>         \"\"     \" -> \"     \" -> \"         \"\"  # Names of the notations can be retained, in which case # the return value is always a list. infer_notation(\"a -> b\", retain_names = TRUE) #> $arrow_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"     \" -> \"     \" -> \"         \"\"  #>  # This function is vectorized. # The list of labels matches # all known notations in `RCLabels::notations_list`. infer_notation(c(\"a -> b\", \"a (b)\", \"a [b]\", \"a [from b]\", \"a [of b]\",                  \"a [to b]\", \"a [in b]\", \"a [-> b]\", \"a.b\"),                  retain_names = TRUE) #> $arrow_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"     \" -> \"     \" -> \"         \"\"  #>  #> $paren_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"       \" (\"       \" (\"        \")\"  #>  #> $bracket_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"       \" [\"       \" [\"        \"]\"  #>  #> $from_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"  \" [from \"  \" [from \"        \"]\"  #>  #> $of_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"    \" [of \"    \" [of \"        \"]\"  #>  #> $to_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"    \" [to \"    \" [to \"        \"]\"  #>  #> $in_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"    \" [in \"    \" [in \"        \"]\"  #>  #> $bracket_arrow_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"    \" [-> \"    \" [-> \"        \"]\"  #>  #> $first_dot_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"        \".\"        \".\"         \"\"  #>  # By default, the most specific notation is returned. # But when two or more matches are present, # multiple notations can be returned, too. infer_notation(\"a [from b]\",                allow_multiple = TRUE, retain_names = TRUE,                choose_most_specific = FALSE) #> $bracket_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"       \" [\"       \" [\"        \"]\"  #>  #> $from_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"  \" [from \"  \" [from \"        \"]\"  #>  infer_notation(c(\"a [from b]\", \"c [to d]\"),                allow_multiple = TRUE, retain_names = TRUE,                choose_most_specific = FALSE) #> [[1]] #> [[1]]$bracket_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"       \" [\"       \" [\"        \"]\"  #>  #> [[1]]$from_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"  \" [from \"  \" [from \"        \"]\"  #>  #>  #> [[2]] #> [[2]]$bracket_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"       \" [\"       \" [\"        \"]\"  #>  #> [[2]]$to_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"    \" [to \"    \" [to \"        \"]\"  #>  #>  # As shown above, \"a \\[from b\\]\" matches 2 notations: # `RCLabels::bracket_notation` and `RCLabels::from_notation`. # The default value for the notation argument is # RCLabels::notations_list, # which includes `RCLabels::bracket_notation` # and `RCLabels::from_notation` in that order. # Thus, there is some flexibility to how this function works # if the value of the `notation` argument is a list of notations # ordered from least specific to most specific, # as `RCLabels::notations_list` is ordered. # To review, the next call returns both `RCLabels::bracket_notation` and # `RCLabels::from_notation`, because `allow_multiple = TRUE` and # `choose_most_specific = FALSE`, neither of which are default. infer_notation(\"a [from b]\",                allow_multiple = TRUE,                choose_most_specific = FALSE,                retain_names = TRUE) #> $bracket_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"       \" [\"       \" [\"        \"]\"  #>  #> $from_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"  \" [from \"  \" [from \"        \"]\"  #>  # The next call returns `RCLabels::from_notation`, because # the most specific notation is requested, and # `RCLabels::from_notation` has more characters in its specification than # `RCLabels::bracket_notation`. infer_notation(\"a [from b]\",                choose_most_specific = TRUE,                retain_names = TRUE) #> $from_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"  \" [from \"  \" [from \"        \"]\"  #>  # The next call returns the `RCLabels::bracket_notation`, because # `choose_most_specific = FALSE`, and the first matching # notation in `RCLabels::notations_list` is `RCLabels::bracket_notation`. infer_notation(\"a [from b]\",                choose_most_specific = FALSE,                retain_names = TRUE) #> $bracket_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"       \" [\"       \" [\"        \"]\"  #>"},{"path":"https://matthewheun.github.io/RCLabels/reference/infer_notation_for_one_label.html","id":null,"dir":"Reference","previous_headings":"","what":"Infer the notation from one row or column label — infer_notation_for_one_label","title":"Infer the notation from one row or column label — infer_notation_for_one_label","text":"non-public helper function vectorized infer_notation().","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/infer_notation_for_one_label.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Infer the notation from one row or column label — infer_notation_for_one_label","text":"","code":"infer_notation_for_one_label(   x,   inf_notation = TRUE,   notations = RCLabels::notations_list,   allow_multiple = FALSE,   retain_names = FALSE,   choose_most_specific = TRUE,   must_succeed = TRUE )"},{"path":"https://matthewheun.github.io/RCLabels/reference/infer_notation_for_one_label.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Infer the notation from one row or column label — infer_notation_for_one_label","text":"x single row column label. inf_notation boolean tells whether infer notation x. notations list notations matches inferred function might work expected notation list. notation list, notations returned full. Default RCLabels::notations_list. allow_multiple boolean tells whether multiple notation matches allowed. FALSE (default), multiple matches give error. retain_names boolean tells whether retain names outgoing matches. Default FALSE. TRUE, return value named list. one notations returned, names never supplied. choose_most_specific boolean indicates -specific notation returned one notations matches x. Default TRUE. must_succeed boolean TRUE (default), causes error thrown matching notation found label x. FALSE, unsuccessful label inference return NULL.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/infer_notation_for_one_label.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Infer the notation from one row or column label — infer_notation_for_one_label","text":"single matching notation object (allow_multiple = FALSE, default) possibly multiple matching notation objects (allow_multiple = TRUE). notations match x, NULL.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/make_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Make a list of items in x, regardless of x's type — make_list","title":"Make a list of items in x, regardless of x's type — make_list","text":"Repeats x necessary make n . try simplify x.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/make_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make a list of items in x, regardless of x's type — make_list","text":"","code":"make_list(x, n, lenx = ifelse(is.vector(x), length(x), 1))"},{"path":"https://matthewheun.github.io/RCLabels/reference/make_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make a list of items in x, regardless of x's type — make_list","text":"x object duplicated. n number times duplicated. lenx length item x. default, lenx taken length(x),","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/make_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make a list of items in x, regardless of x's type — make_list","text":"list x duplicated n times","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/make_list.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Make a list of items in x, regardless of x's type — make_list","text":"x vector list, may want override default value lenx. example, x list duplicated several times, set lenx = 1.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/make_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make a list of items in x, regardless of x's type — make_list","text":"","code":"m <- matrix(c(1:6), nrow=3, dimnames = list(c(\"r1\", \"r2\", \"r3\"), c(\"c2\", \"c1\"))) make_list(m, n = 1) #> [[1]] #>    c2 c1 #> r1  1  4 #> r2  2  5 #> r3  3  6 #>  make_list(m, n = 2) #> [[1]] #>    c2 c1 #> r1  1  4 #> r2  2  5 #> r3  3  6 #>  #> [[2]] #>    c2 c1 #> r1  1  4 #> r2  2  5 #> r3  3  6 #>  make_list(m, n = 5) #> [[1]] #>    c2 c1 #> r1  1  4 #> r2  2  5 #> r3  3  6 #>  #> [[2]] #>    c2 c1 #> r1  1  4 #> r2  2  5 #> r3  3  6 #>  #> [[3]] #>    c2 c1 #> r1  1  4 #> r2  2  5 #> r3  3  6 #>  #> [[4]] #>    c2 c1 #> r1  1  4 #> r2  2  5 #> r3  3  6 #>  #> [[5]] #>    c2 c1 #> r1  1  4 #> r2  2  5 #> r3  3  6 #>  make_list(list(c(1,2), c(1,2)), n = 4) #> [[1]] #> [1] 1 2 #>  #> [[2]] #> [1] 1 2 #>  #> [[3]] #> [1] 1 2 #>  #> [[4]] #> [1] 1 2 #>  m <- matrix(1:4, nrow = 2) l <- list(m, m+100) make_list(l, n = 4) #> [[1]] #>      [,1] [,2] #> [1,]    1    3 #> [2,]    2    4 #>  #> [[2]] #>      [,1] [,2] #> [1,]  101  103 #> [2,]  102  104 #>  #> [[3]] #>      [,1] [,2] #> [1,]    1    3 #> [2,]    2    4 #>  #> [[4]] #>      [,1] [,2] #> [1,]  101  103 #> [2,]  102  104 #>  make_list(l, n = 1) # Warning because l is trimmed. #> Warning: n not evenly divisible by length(x) #>      [,1] [,2] #> [1,]    1    3 #> [2,]    2    4 make_list(l, n = 5) # Warning because length(l) (i.e., 2) not evenly divisible by 5 #> Warning: n not evenly divisible by length(x) #> [[1]] #>      [,1] [,2] #> [1,]    1    3 #> [2,]    2    4 #>  #> [[2]] #>      [,1] [,2] #> [1,]  101  103 #> [2,]  102  104 #>  #> [[3]] #>      [,1] [,2] #> [1,]    1    3 #> [2,]    2    4 #>  #> [[4]] #>      [,1] [,2] #> [1,]  101  103 #> [2,]  102  104 #>  #> [[5]] #>      [,1] [,2] #> [1,]    1    3 #> [2,]    2    4 #>  make_list(list(c(\"r10\", \"r11\"), c(\"c10\", \"c11\")), n = 2) # Confused by x being a list #> [[1]] #> [1] \"r10\" \"r11\" #>  #> [[2]] #> [1] \"c10\" \"c11\" #>  make_list(list(c(\"r10\", \"r11\"), c(\"c10\", \"c11\")), n = 2, lenx = 1) # Fix by setting lenx = 1 #> [[1]] #> [[1]][[1]] #> [1] \"r10\" \"r11\" #>  #> [[1]][[2]] #> [1] \"c10\" \"c11\" #>  #>  #> [[2]] #> [[2]][[1]] #> [1] \"r10\" \"r11\" #>  #> [[2]][[2]] #> [1] \"c10\" \"c11\" #>  #>"},{"path":"https://matthewheun.github.io/RCLabels/reference/make_or_pattern.html","id":null,"dir":"Reference","previous_headings":"","what":"Create ","title":"Create ","text":"function makes \"\" regex patterns vectors lists strings. function can used matsbyname::select_rows_byname() matsbyname::select_cols_byname functions. make_or_pattern() correctly escapes special characters strings, ( ), needed. Thus, highly recommended make_or_pattern used constructing patterns row column selections matsbyname::select_rows_byname() matsbyname::select_cols_byname().","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/make_or_pattern.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create ","text":"","code":"make_or_pattern(   strings,   pattern_type = c(\"exact\", \"leading\", \"trailing\", \"anywhere\", \"literal\") )"},{"path":"https://matthewheun.github.io/RCLabels/reference/make_or_pattern.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create ","text":"strings vector row column names. pattern_type One \"exact\", \"leading\", \"trailing\", \"anywhere\", \"literal\". Default \"exact\".","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/make_or_pattern.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create ","text":"\"\" regex pattern suitable selecting row column names. Amenable use matsbyname::select_rows_byname matsbyname::select_cols_byname.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/make_or_pattern.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create ","text":"pattern_type controls type pattern created: exact produces regex pattern selects row column names exact match. leading produces regex pattern selects row column names item strings matches beginnings row column names. trailing produces regex pattern selects row column names item strings matches ends row column names. anywhere produces regex pattern selects row column names item strings matches substring row column names. literal returns strings unmodified, caller formulate correct regex.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/make_or_pattern.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create ","text":"","code":"make_or_pattern(strings = c(\"a\", \"b\"), pattern_type = \"exact\") #> [1] \"^a$|^b$\" make_or_pattern(strings = c(\"a\", \"b\"), pattern_type = \"leading\") #> [1] \"^a|^b\" make_or_pattern(strings = c(\"a\", \"b\"), pattern_type = \"trailing\") #> [1] \"a$|b$\" make_or_pattern(strings = c(\"a\", \"b\"), pattern_type = \"anywhere\") #> [1] \"a|b\" make_or_pattern(strings = c(\"a\", \"b\"), pattern_type = \"literal\") #> [1] \"a\" \"b\""},{"path":"https://matthewheun.github.io/RCLabels/reference/modify_label_pieces.html","id":null,"dir":"Reference","previous_headings":"","what":"Modify pieces of row and column labels — modify_label_pieces","title":"Modify pieces of row and column labels — modify_label_pieces","text":"Typical pieces include \"noun\" preposition, \"\" \"\". See RCLabels::prepositions additional examples. argument may single string character vector.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/modify_label_pieces.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Modify pieces of row and column labels — modify_label_pieces","text":"","code":"modify_label_pieces(   labels,   piece,   mod_map,   prepositions = RCLabels::prepositions_list,   inf_notation = TRUE,   notation = RCLabels::bracket_notation,   choose_most_specific = FALSE )"},{"path":"https://matthewheun.github.io/RCLabels/reference/modify_label_pieces.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Modify pieces of row and column labels — modify_label_pieces","text":"labels vector row column labels pieces modified. piece piece (pieces) row column label modified. mod_map modification map. See details. prepositions list prepositions, used detect prepositional phrases. Default RCLabels::prepositions_list. inf_notation boolean tells whether infer notation x. Default TRUE. See infer_notation() details. notation notation type used extracting prepositions. Default RCLabels::notations_list, meaning notation inferred using infer_notation(). choose_most_specific boolean tells whether specific notation selected one notation match. Default FALSE.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/modify_label_pieces.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Modify pieces of row and column labels — modify_label_pieces","text":"labels replacements according piece mod_map.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/modify_label_pieces.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Modify pieces of row and column labels — modify_label_pieces","text":"function modifies pieces row column labels according label_map defines \"one many one\" relationships. function useful aggregations. example, replacing nouns can done modify_label_pieces(labels, piece = \"noun\", label_map = list(new_noun = c(\"\", \"b\", \"c\")). string \"new_noun\" replace \"\", \"b\", \"c\" appear nouns row column label. See examples details. mod_map argument consist named list character vectors names indicate strings inserted values indicate values replaced. sense new = old new = olds, \"new\" new name (replacement) \"old\"/\"olds\" /string/vector strings, one replaced \"new\". Note piece can \"pref\"/\"suff\" \"noun\"/\"prepositions\" piece \"pref\" \"suff\", pieces assumed prefix suffix. non pieces \"pref\" \"suff\", pieces assumed nouns prepositions, \"\" \"\". See RCLabels::prepositions additional examples. argument may single string character vector.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/modify_label_pieces.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Modify pieces of row and column labels — modify_label_pieces","text":"","code":"# Simple case modify_label_pieces(\"a [of b in c]\",                     piece = \"noun\",                     mod_map = list(new_noun = c(\"a\", \"b\"))) #> [1] \"new_noun [of b in c]\" # Works with a vector or list of labels modify_label_pieces(c(\"a [of b in c]\", \"d [-> e in f]\"),                     piece = \"noun\",                     mod_map = list(new_noun = c(\"d\", \"e\"))) #> [1] \"a [of b in c]\"        \"new_noun [-> e in f]\" # Works with multiple items in the mod_map modify_label_pieces(c(\"a [of b in c]\", \"d [-> e in f]\"),                     piece = \"noun\",                     mod_map = list(new_noun1 = c(\"a\", \"b\", \"c\"),                                    new_noun2 = c(\"d\", \"e\", \"f\"))) #> [1] \"new_noun1 [of b in c]\" \"new_noun2 [-> e in f]\" # Works with multiple pieces to be modified modify_label_pieces(c(\"a [of b in c]\", \"d [-> e in f]\"),                     piece = c(\"noun\", \"in\"),                     mod_map = list(new_noun = c(\"a\", \"b\", \"c\"),                                    new_in   = c(\"c\", \"f\"))) #> [1] \"new_noun [of b in new_in]\" \"d [-> e in new_in]\""},{"path":"https://matthewheun.github.io/RCLabels/reference/modify_nouns.html","id":null,"dir":"Reference","previous_headings":"","what":"Modify nouns in labels — modify_nouns","title":"Modify nouns in labels — modify_nouns","text":"function modifies nouns row column labels. length new_nouns must length labels.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/modify_nouns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Modify nouns in labels — modify_nouns","text":"","code":"modify_nouns(   labels,   new_nouns,   inf_notation = TRUE,   notation = RCLabels::notations_list,   choose_most_specific = FALSE )"},{"path":"https://matthewheun.github.io/RCLabels/reference/modify_nouns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Modify nouns in labels — modify_nouns","text":"labels row column labels nouns modified. new_nouns new nouns set labels. Must length labels. inf_notation boolean tells whether infer notation labels. Default TRUE. See infer_notation() details. notation notation type used extracting prepositions. Default RCLabels::notations_list, meaning notation inferred using infer_notation(). choose_most_specific boolean tells whether choose specific notation notation inferring notation. Default FALSE less specific notation can inferred. combination RCLabels::notations_list, default value FALSE means RCLabels::bracket_notation selected instead anything specific, RCLabels::from_notation.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/modify_nouns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Modify nouns in labels — modify_nouns","text":"character vector length labels nouns modified new_nouns.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/modify_nouns.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Modify nouns in labels — modify_nouns","text":"","code":"labels <- c(\"a [of b in c]\", \"d [of e in USA]\") modify_nouns(labels, c(\"a_plus\", \"g\")) #> [1] \"a_plus [of b in c]\" \"g [of e in USA]\""},{"path":"https://matthewheun.github.io/RCLabels/reference/notations_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Notations list — notations_list","title":"Notations list — notations_list","text":"list bundled notations. list organized least specific specific, thereby enabling unique behaviors infer_notation(). See examples infer_notation().","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/notations_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Notations list — notations_list","text":"","code":"notations_list"},{"path":"https://matthewheun.github.io/RCLabels/reference/notations_list.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Notations list — notations_list","text":"list bundled notations.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/notations_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Notations list — notations_list","text":"","code":"notations_list #> $first_dot_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"        \".\"        \".\"         \"\"  #>  #> $dash_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"      \" - \"      \" - \"         \"\"  #>  #> $arrow_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"     \" -> \"     \" -> \"         \"\"  #>  #> $paren_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"       \" (\"       \" (\"        \")\"  #>  #> $bracket_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"       \" [\"       \" [\"        \"]\"  #>  #> $from_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"  \" [from \"  \" [from \"        \"]\"  #>  #> $of_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"    \" [of \"    \" [of \"        \"]\"  #>  #> $to_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"    \" [to \"    \" [to \"        \"]\"  #>  #> $in_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"    \" [in \"    \" [in \"        \"]\"  #>  #> $bracket_arrow_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"    \" [-> \"    \" [-> \"        \"]\"  #>"},{"path":"https://matthewheun.github.io/RCLabels/reference/of_notation.html","id":null,"dir":"Reference","previous_headings":"","what":"Of notation — of_notation","title":"Of notation — of_notation","text":"description notation.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/of_notation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Of notation — of_notation","text":"","code":"of_notation"},{"path":"https://matthewheun.github.io/RCLabels/reference/of_notation.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Of notation — of_notation","text":"vector notational symbols provides (\"[b]\") notation.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/of_notation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Of notation — of_notation","text":"","code":"of_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"    \" [of \"    \" [of \"        \"]\""},{"path":"https://matthewheun.github.io/RCLabels/reference/paren_notation.html","id":null,"dir":"Reference","previous_headings":"","what":"Parenthetical notation — paren_notation","title":"Parenthetical notation — paren_notation","text":"description parenthetical notation.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/paren_notation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parenthetical notation — paren_notation","text":"","code":"paren_notation"},{"path":"https://matthewheun.github.io/RCLabels/reference/paren_notation.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Parenthetical notation — paren_notation","text":"vector notational symbols provides parenthetical (\"(b)\") notation.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/paren_notation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parenthetical notation — paren_notation","text":"","code":"paren_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"       \" (\"       \" (\"        \")\""},{"path":"https://matthewheun.github.io/RCLabels/reference/paste_noun_pp.html","id":null,"dir":"Reference","previous_headings":"","what":"Recombine row and column labels — paste_noun_pp","title":"Recombine row and column labels — paste_noun_pp","text":"function recombines (unsplits) row column labels separated split_noun_pp().","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/paste_noun_pp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Recombine row and column labels — paste_noun_pp","text":"","code":"paste_noun_pp(   splt_labels,   notation = RCLabels::bracket_notation,   squish = TRUE )"},{"path":"https://matthewheun.github.io/RCLabels/reference/paste_noun_pp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Recombine row and column labels — paste_noun_pp","text":"splt_labels vector split row column labels, probably created split_noun_pp(). notation notation object describes labels. Default RCLabels::bracket_notation. squish boolean tells whether remove extra spaces output paste_*() functions. Default TRUE.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/paste_noun_pp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Recombine row and column labels — paste_noun_pp","text":"Recombined row column labels.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/paste_noun_pp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Recombine row and column labels — paste_noun_pp","text":"","code":"labs <- c(\"a [of b in c]\", \"d [from Coal mines in USA]\") labs #> [1] \"a [of b in c]\"              \"d [from Coal mines in USA]\" split <- split_noun_pp(labs) split #> [[1]] #> noun   of   in  #>  \"a\"  \"b\"  \"c\"  #>  #> [[2]] #>         noun         from           in  #>          \"d\" \"Coal mines\"        \"USA\"  #>  paste_noun_pp(split) #> [1] \"a [of b in c]\"              \"d [from Coal mines in USA]\" # Also works in a data frame df <- tibble::tibble(labels = c(\"a [in b]\", \"c [of d into USA]\",                                 \"e [of f in g]\", \"h [-> i in j]\")) recombined <- df %>%   dplyr::mutate(     splits = split_noun_pp(labels),     recombined = paste_noun_pp(splits)   ) all(recombined$labels == recombined$recombined) #> [1] TRUE"},{"path":"https://matthewheun.github.io/RCLabels/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://matthewheun.github.io/RCLabels/reference/prepositions.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepositions — prepositions","title":"Prepositions — prepositions","text":"constant deprecated. Please use prepositiions_list instead.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/prepositions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepositions — prepositions","text":"","code":"prepositions"},{"path":"https://matthewheun.github.io/RCLabels/reference/prepositions.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Prepositions — prepositions","text":"vector prepositions used row column labels.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/prepositions_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepositions — prepositions_list","title":"Prepositions — prepositions_list","text":"Prepositions used row column labels.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/prepositions_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepositions — prepositions_list","text":"","code":"prepositions_list"},{"path":"https://matthewheun.github.io/RCLabels/reference/prepositions_list.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Prepositions — prepositions_list","text":"vector prepositions used row column labels.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/prepositions_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prepositions — prepositions_list","text":"","code":"prepositions_list #> [1] \"in\"   \"into\" \"from\" \"of\"   \"->\"   \"to\""},{"path":"https://matthewheun.github.io/RCLabels/reference/recombine_labels.html","id":null,"dir":"Reference","previous_headings":"","what":"Recombine row and column labels — recombine_labels","title":"Recombine row and column labels — recombine_labels","text":"function recombines (unsplits) row column labels separated split_noun_pp().","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/recombine_labels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Recombine row and column labels — recombine_labels","text":"","code":"recombine_labels(ls, notation = RCLabels::bracket_notation)"},{"path":"https://matthewheun.github.io/RCLabels/reference/recombine_labels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Recombine row and column labels — recombine_labels","text":"ls vector split row column labels, probably created split_noun_pp(). notation notation object describes labels. Default RCLabels::bracket_notation.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/recombine_labels.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Recombine row and column labels — recombine_labels","text":"Recombined row column labels.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/recombine_labels.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Recombine row and column labels — recombine_labels","text":"","code":"labs <- c(\"a [of b in c]\", \"d [from Coal mines in USA]\") labs #> [1] \"a [of b in c]\"              \"d [from Coal mines in USA]\" split <- split_labels(labs) split #> [[1]] #> noun   of   in  #>  \"a\"  \"b\"  \"c\"  #>  #> [[2]] #>         noun         from           in  #>          \"d\" \"Coal mines\"        \"USA\"  #>  recombine_labels(split) #> [1] \"a [of b in c]\"              \"d [from Coal mines in USA]\" # Also works in a data frame df <- tibble::tibble(labels = c(\"a [in b]\", \"c [of d into USA]\",                                 \"e [of f in g]\", \"h [-> i in j]\")) recombined <- df |>   dplyr::mutate(     splits = split_labels(labels),     recombined = recombine_labels(splits)   ) all(recombined$labels == recombined$recombined) #> [1] TRUE"},{"path":"https://matthewheun.github.io/RCLabels/reference/regex_funcs.html","id":null,"dir":"Reference","previous_headings":"","what":"Find or replace row or column labels that match a regular expression — regex_funcs","title":"Find or replace row or column labels that match a regular expression — regex_funcs","text":"match_by_pattern() tells whether row column labels match regular expression. Internally, grepl() decides whether match occurs. replace_by_pattern() replaces portions row column labels regular expression matched. Internally, gsub() performs replacements.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/regex_funcs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find or replace row or column labels that match a regular expression — regex_funcs","text":"","code":"match_by_pattern(   labels,   regex_pattern,   pieces = \"all\",   prepositions = RCLabels::prepositions_list,   notation = RCLabels::bracket_notation,   inf_notation = TRUE,   choose_most_specific = FALSE,   ... )  replace_by_pattern(   labels,   regex_pattern,   replacement,   pieces = \"all\",   prepositions = RCLabels::prepositions_list,   notation = RCLabels::bracket_notation,   ... )"},{"path":"https://matthewheun.github.io/RCLabels/reference/regex_funcs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find or replace row or column labels that match a regular expression — regex_funcs","text":"labels row column labels modified. regex_pattern regular expression pattern determine matches replacements. Consider using Hmisc::escapeRegex() escape regex_pattern calling function. pieces pieces row column labels checked matches replacements. See details. prepositions vector strings count prepositions. Default prepositions_list. Used detect prepositional phrases pieces interpreted prepositions. notation notation used labels. Default bracket_notation. inf_notation boolean tells whether infer notation x. Default TRUE. See infer_notation() details. choose_most_specific boolean tells whether choose specific notation notation inferring notation. Default FALSE less specific notation can inferred. combination notations_list, default value FALSE means bracket_notation selected instead anything specific, from_notation. ... arguments passed grepl() gsub(), ignore.case, perl, fixed, useBytes. See examples. replacement replace_by_pattern(), string replaces matches regex_pattern.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/regex_funcs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find or replace row or column labels that match a regular expression — regex_funcs","text":"logical vector length labels, TRUE indicates match found FALSE indicates otherwise.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/regex_funcs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Find or replace row or column labels that match a regular expression — regex_funcs","text":"default (pieces = \"\"), complete labels (strings) checked matches replacements. pieces == \"pref\" pieces == \"suff\", prefix suffix checked matches replacements. Alternatively, pieces = \"noun\" pieces = <<preposition>> indicate specific pieces labels checked matches replacements. pieces = <<preposition>>, object <<preposition>> checked matches replacement. pieces can vector, indicating multiple pieces checked matches replacements. pieces \"\", pieces checked replaced. pieces \"pref\" \"suff\", one can specified.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/regex_funcs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find or replace row or column labels that match a regular expression — regex_funcs","text":"","code":"labels <- c(\"Production [of b in c]\", \"d [of Coal in f]\", \"g [of h in USA]\") # With default `pieces` argument, matching is done for whole labels. match_by_pattern(labels, regex_pattern = \"Production\") #> [1]  TRUE FALSE FALSE match_by_pattern(labels, regex_pattern = \"Coal\") #> [1] FALSE  TRUE FALSE match_by_pattern(labels, regex_pattern = \"USA\") #> [1] FALSE FALSE  TRUE # Check beginnings of labels match_by_pattern(labels, regex_pattern = \"^Production\") #> [1]  TRUE FALSE FALSE # Check at ends of labels: no match. match_by_pattern(labels, regex_pattern = \"Production$\") #> [1] FALSE FALSE FALSE # Can match on nouns or prepositions. match_by_pattern(labels, regex_pattern = \"Production\", pieces = \"noun\") #> [1]  TRUE FALSE FALSE # Gives FALSE, because \"Production\" is a noun. match_by_pattern(labels, regex_pattern = \"Production\", pieces = \"in\") #> [1] FALSE FALSE FALSE"},{"path":"https://matthewheun.github.io/RCLabels/reference/remove_label_pieces.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove a prepositional phrase in a row or column label — remove_label_pieces","title":"Remove a prepositional phrase in a row or column label — remove_label_pieces","text":"function removes pieces row column labels.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/remove_label_pieces.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove a prepositional phrase in a row or column label — remove_label_pieces","text":"","code":"remove_label_pieces(   labels,   pieces_to_remove,   prepositions = RCLabels::prepositions_list,   inf_notation = TRUE,   notation = RCLabels::notations_list,   choose_most_specific = FALSE )"},{"path":"https://matthewheun.github.io/RCLabels/reference/remove_label_pieces.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove a prepositional phrase in a row or column label — remove_label_pieces","text":"labels row column labels prepositional phrases removed. pieces_to_remove names pieces label removed, typically \"noun\" preposition \"\" \"\" See RCLabels::prepositions_list list known prepositions. prepositions list prepositions, used detect prepositional phrases. Default RCLabels::prepositions_list. inf_notation boolean tells whether infer notation x. Default TRUE. See infer_notation() details. notation notation type used extracting prepositions. Default RCLabels::notations_list, meaning notation inferred using infer_notation(). choose_most_specific boolean tells whether specific notation selected one notation match. Default FALSE.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/remove_label_pieces.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove a prepositional phrase in a row or column label — remove_label_pieces","text":"labels pieces removed.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/remove_label_pieces.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Remove a prepositional phrase in a row or column label — remove_label_pieces","text":"","code":"labs <- c(\"a [of b in c]\", \"d [-> e in f]\") remove_label_pieces(labs, pieces_to_remove = \"of\") #> [1] \"a [in c]\"      \"d [-> e in f]\" remove_label_pieces(labs, pieces_to_remove = c(\"of\", \"->\")) #> [1] \"a [in c]\" \"d [in f]\" remove_label_pieces(labs, pieces_to_remove = c(\"in\", \"into\")) #> [1] \"a [of b]\" \"d [-> e]\" remove_label_pieces(labs, pieces_to_remove = c(\"of\", \"in\")) #> [1] \"a [ ]\"    \"d [-> e]\""},{"path":"https://matthewheun.github.io/RCLabels/reference/row-col-notation.html","id":null,"dir":"Reference","previous_headings":"","what":"Row and column notation — row-col-notation","title":"Row and column notation — row-col-notation","text":"often convenient represent matrix row column names notation includes prefix suffix, corresponding separators start-end string sequences. several functions generate specialized versions otherwise manipulate row column names row column names. flip_pref_suff() Switches location prefix suffix, prefix becomes suffix, suffix becomes prefix. E.g., \"-> b\" becomes \"b -> \" \"[b]\" becomes \"b []\". get_pref_suff() Selects prefix suffix, discarding notational elements rejected part. Internally, function calls split_pref_suff() selects desired portion. notation_vec() Builds vector notation symbols standard format. default, builds list notation symbols provides arrow separator (\" -> \") prefix suffix. paste_pref_suff() paste0's prefixes suffixes, inverse split_pref_suff(). Always returns character vector. preposition_notation() Builds list notation symbols provides (default) square brackets around suffix preposition (\"prefix [preposition suffix]\"). split_pref_suff() Splits prefixes suffixes, returning list names pref suff. prefix suffix delimiters found, x returned pref item, unmodified, suff item returned \"\" (empty string). prefix, empty string returned pref item. suffix, empty string returned suff item. switch_notation() Switches one type notation another based arguments. Optionally, prefix suffix can flipped. Parts notation vector \"pref_start\", \"pref_end\", \"suff_start\", \"suff_end\". None strings notation vector considered part prefix suffix. E.g., \"-> b\" arrow notation means \"\" prefix \"b\" suffix. sep specified notation_vec() (default \" -> \"), pref_start, pref_end, suff_start, suff_end set appropriately. functions notation argument used identify portions row column label (split_pref_suff(), get_pref_suff(), argument switch_notation()), (Note: flip_pref_suff() infer notation, switches prefix suffix known, single notation.) notation list, treated store appropriate notation inferred infer_notation(choose_most_specific = TRUE). default RCLabels::notations_list, notation inferred default. argument choose_most_specific tells two notations match label: TRUE (default), notation characters selected. FALSE, first matching notation notation selected. See details infer_notation(). specifying one notation, sure notations list. notation = c(RCLabels::bracket_notation, RCLabels::arrow_notation) unlikely produce desired result, notations concatenated together form long string vector. Rather say notation = list(RCLabels::bracket_notation, RCLabels::arrow_notation). functions construct labels (paste_pref_suff()), notation can list notations paste tasks mapped. notation list, must many items prefix/suffix pairs pasted. either pref suff zero-length character vector (essentially empty character vector obtained character()) input paste_pref_suff(), error thrown. Instead, use empty character string (obtained \"\").","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/row-col-notation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Row and column notation — row-col-notation","text":"","code":"notation_vec(   sep = \" -> \",   pref_start = \"\",   pref_end = \"\",   suff_start = \"\",   suff_end = \"\" )  preposition_notation(preposition, suff_start = \" [\", suff_end = \"]\")  split_pref_suff(   x,   transpose = FALSE,   inf_notation = TRUE,   notation = RCLabels::notations_list,   choose_most_specific = TRUE )  paste_pref_suff(   ps = list(pref = pref, suff = suff),   pref = NULL,   suff = NULL,   notation = RCLabels::arrow_notation,   squish = TRUE )  flip_pref_suff(   x,   notation = RCLabels::notations_list,   inf_notation = TRUE,   choose_most_specific = TRUE )  get_pref_suff(   x,   which = c(\"pref\", \"suff\"),   inf_notation = TRUE,   notation = RCLabels::notations_list,   choose_most_specific = TRUE )  switch_notation(   x,   from = RCLabels::notations_list,   to,   flip = FALSE,   inf_notation = TRUE )"},{"path":"https://matthewheun.github.io/RCLabels/reference/row-col-notation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Row and column notation — row-col-notation","text":"sep string separator prefix suffix. Default \" -> \". pref_start string indicating start prefix. Default NULL. pref_end string indicating end prefix. Default value sep. suff_start string indicating start suffix. Default value sep. suff_end string indicating end suffix. Default NULL. preposition string used indicate position energy flows, typically \"\" \"\" different notations. x string vector strings operated upon. transpose boolean tells whether purr::transpose() result. Set transpose = TRUE using split_pref_suff() dplyr::mutate() call context data frame. Default FALSE. inf_notation boolean tells whether infer notation x. Default TRUE. See infer_notation() details. notation notation vector generated one *_notation() functions, notation_vec(), arrow_notation, bracket_notation. choose_most_specific boolean tells whether choose specific notation notation argument notation argument list. ps list prefixes suffixes item list list two items named pref suff. pref string list strings prefixes. Default NULL. suff string list strings suffixes. Default NULL. squish boolean tells whether remove extra spaces output paste_*() functions. Default TRUE. Tells keep, prefix (\"pref\") suffix (\"suff\"). notation switch away . notation switch . flip boolean tells whether also flip notation. Default FALSE.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/row-col-notation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Row and column notation — row-col-notation","text":"notation_vec(), arrow_notation, bracket_notation, string vector named items pref_start, pref_end, suff_start, suff_end; split_pref_suff(), string list named items pref suff. paste_pref_suff(), split_pref_suff(), switch_notation(), string list notation format specified various notation arguments, including , . keep_pref_suff, one prefix suffix list prefixes suffixes.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/row-col-notation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Row and column notation — row-col-notation","text":"","code":"notation_vec() #> pref_start   pref_end suff_start   suff_end  #>         \"\"     \" -> \"     \" -> \"         \"\"  arrow_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"     \" -> \"     \" -> \"         \"\"  bracket_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"       \" [\"       \" [\"        \"]\"  split_pref_suff(\"a -> b\", notation = arrow_notation) #> $pref #> [1] \"a\" #>  #> $suff #> [1] \"b\" #>  # Or infer the notation (by default from notations_list) split_pref_suff(\"a -> b\") #> $pref #> [1] \"a\" #>  #> $suff #> [1] \"b\" #>  split_pref_suff(c(\"a -> b\", \"c -> d\", \"e -> f\")) #> $pref #> [1] \"a\" \"c\" \"e\" #>  #> $suff #> [1] \"b\" \"d\" \"f\" #>  split_pref_suff(c(\"a -> b\", \"c -> d\", \"e -> f\"), transpose = TRUE) #> [[1]] #> [[1]]$pref #> [1] \"a\" #>  #> [[1]]$suff #> [1] \"b\" #>  #>  #> [[2]] #> [[2]]$pref #> [1] \"c\" #>  #> [[2]]$suff #> [1] \"d\" #>  #>  #> [[3]] #> [[3]]$pref #> [1] \"e\" #>  #> [[3]]$suff #> [1] \"f\" #>  #>  flip_pref_suff(\"a [b]\", notation = bracket_notation) #> [1] \"b [a]\" # Infer notation flip_pref_suff(\"a [b]\") #> [1] \"b [a]\" get_pref_suff(\"a -> b\", which = \"suff\") #> suff  #>  \"b\"  switch_notation(\"a -> b\", from = arrow_notation, to = bracket_notation) #> [1] \"a [b]\" # Infer notation and flip prefix and suffix switch_notation(\"a -> b\", to = bracket_notation, flip = TRUE) #> [1] \"b [a]\" # Also works for vectors switch_notation(c(\"a -> b\", \"c -> d\"),                 from = arrow_notation,                 to = bracket_notation) #> [[1]] #> [1] \"a [b]\" #>  #> [[2]] #> [1] \"c [d]\" #>  # Functions can infer the correct notation and return multiple matches infer_notation(\"a [to b]\",                allow_multiple = TRUE,                choose_most_specific = FALSE) #> [[1]] #> pref_start   pref_end suff_start   suff_end  #>         \"\"       \" [\"       \" [\"        \"]\"  #>  #> [[2]] #> pref_start   pref_end suff_start   suff_end  #>         \"\"    \" [to \"    \" [to \"        \"]\"  #>  # Or choose the most specific notation infer_notation(\"a [to b]\",                allow_multiple = TRUE,                choose_most_specific = TRUE) #> pref_start   pref_end suff_start   suff_end  #>         \"\"    \" [to \"    \" [to \"        \"]\"  # When setting the from notation, only that type of notation will be switched switch_notation(c(\"a -> b\", \"c [to d]\"),                 from = arrow_notation,                 to = bracket_notation) #> [[1]] #> [1] \"a [b]\" #>  #> [[2]] #> [1] \"c [to d]\" #>  # But if notations are inferred, all notations can be switched switch_notation(c(\"a -> b\", \"c [to d]\"), to = bracket_notation) #> [[1]] #> [1] \"a [b]\" #>  #> [[2]] #> [1] \"c [d]\" #>  # A double-switch can be accomplished. # In this first example, `RCLabels::first_dot_notation` is inferred. switch_notation(\"a.b.c\", to = arrow_notation) #> [1] \"a -> b.c\" # In this second example, # it is easier to specify the `from` and `to` notations. switch_notation(\"a.b.c\", to = arrow_notation) %>%   switch_notation(from = first_dot_notation, to = arrow_notation) #> [1] \"a -> b -> c\" # \"\" can be used as an input paste_pref_suff(pref = \"a\", suff = \"\", notation = RCLabels::from_notation) #> [1] \"a [from ]\""},{"path":"https://matthewheun.github.io/RCLabels/reference/split_labels.html","id":null,"dir":"Reference","previous_headings":"","what":"Split row and column labels into nouns and prepositional phrases — split_labels","title":"Split row and column labels into nouns and prepositional phrases — split_labels","text":"function similar split_pref_suff() returns list. However, function's list detailed split_pref_suff(). return value function list first named item prefix (name noun) followed objects prepositional phrases (names prepositions precede objects).","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/split_labels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Split row and column labels into nouns and prepositional phrases — split_labels","text":"","code":"split_labels(   labels,   notation = RCLabels::bracket_notation,   prepositions = RCLabels::prepositions )"},{"path":"https://matthewheun.github.io/RCLabels/reference/split_labels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Split row and column labels into nouns and prepositional phrases — split_labels","text":"labels row column labels prepositional phrases extracted. notation notation object describes labels. Default RCLabels::bracket_notation. prepositions vector strings treated prepositions. Note space appended word internally, , e.g., \"\" becomes \"\". Default RCLabels::prepositions.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/split_labels.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Split row and column labels into nouns and prepositional phrases — split_labels","text":"list lists items named noun pp.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/split_labels.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Split row and column labels into nouns and prepositional phrases — split_labels","text":"Unlike split_pref_suff(), make sense transpose argument split_noun_pp(). Labels may structure, e.g., may different prepositions.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/split_labels.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Split row and column labels into nouns and prepositional phrases — split_labels","text":"","code":"split_labels(c(\"a [of b in c]\", \"d [of e into f]\"),              notation = bracket_notation) #> [[1]] #> noun   of   in  #>  \"a\"  \"b\"  \"c\"  #>  #> [[2]] #> noun   of into  #>  \"d\"  \"e\"  \"f\"  #>"},{"path":"https://matthewheun.github.io/RCLabels/reference/split_noun_pp.html","id":null,"dir":"Reference","previous_headings":"","what":"Split row and column labels into nouns and prepositional phrases — split_noun_pp","title":"Split row and column labels into nouns and prepositional phrases — split_noun_pp","text":"function similar split_pref_suff() returns list. However, function's list detailed split_pref_suff(). return value function list first named item prefix (name noun) followed objects prepositional phrases (names prepositions precede objects).","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/split_noun_pp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Split row and column labels into nouns and prepositional phrases — split_noun_pp","text":"","code":"split_noun_pp(   labels,   inf_notation = TRUE,   notation = RCLabels::notations_list,   choose_most_specific = FALSE,   prepositions = RCLabels::prepositions_list )"},{"path":"https://matthewheun.github.io/RCLabels/reference/split_noun_pp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Split row and column labels into nouns and prepositional phrases — split_noun_pp","text":"labels row column labels prepositional phrases extracted. inf_notation boolean tells whether infer notation x. Default TRUE. See infer_notation() details. notation notation type used extracting prepositions. Default RCLabels::notations_list, meaning notation inferred using infer_notation(). choose_most_specific boolean tells whether choose specific notation notation inferring notation. Default FALSE less specific notation can inferred. combination RCLabels::notations_list, default value FALSE means RCLabels::bracket_notation selected instead anything specific, RCLabels::from_notation. prepositions vector strings treated prepositions. Note space appended word internally, , e.g., \"\" becomes \"\". Default RCLabels::prepositions_list.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/split_noun_pp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Split row and column labels into nouns and prepositional phrases — split_noun_pp","text":"list lists items named noun pp.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/split_noun_pp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Split row and column labels into nouns and prepositional phrases — split_noun_pp","text":"Unlike split_pref_suff(), make sense transpose argument split_noun_pp(). Labels may structure, e.g., may different prepositions.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/split_noun_pp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Split row and column labels into nouns and prepositional phrases — split_noun_pp","text":"","code":"# Specify the notation split_noun_pp(c(\"a [of b in c]\", \"d [of e into f]\"),               notation = bracket_notation) #> [[1]] #> noun   of   in  #>  \"a\"  \"b\"  \"c\"  #>  #> [[2]] #> noun   of into  #>  \"d\"  \"e\"  \"f\"  #>  # Infer the notation via default arguments split_noun_pp(c(\"a [of b in c]\", \"d [of e into f]\")) #> [[1]] #> noun   of   in  #>  \"a\"  \"b\"  \"c\"  #>  #> [[2]] #> noun   of into  #>  \"d\"  \"e\"  \"f\"  #>"},{"path":"https://matthewheun.github.io/RCLabels/reference/strip_label_part.html","id":null,"dir":"Reference","previous_headings":"","what":"A convenience function to help splitting prefixes and suffixes — strip_label_part","title":"A convenience function to help splitting prefixes and suffixes — strip_label_part","text":"function ever see single label (x) single notation.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/strip_label_part.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A convenience function to help splitting prefixes and suffixes — strip_label_part","text":"","code":"strip_label_part(x, notation, part, pattern_pref = \"\", pattern_suff = \"\")"},{"path":"https://matthewheun.github.io/RCLabels/reference/strip_label_part.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A convenience function to help splitting prefixes and suffixes — strip_label_part","text":"x label(s) split. notation notations used x. part part label work , \"pref_start\", \"pref_end\", \"suff_start\", \"suff_end\". pattern_pref prefix regex pattern used gsub(). pattern_suff suffix regex pattern used gsub().","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/strip_label_part.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A convenience function to help splitting prefixes and suffixes — strip_label_part","text":"label shorn part stripped.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/strip_label_part.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"A convenience function to help splitting prefixes and suffixes — strip_label_part","text":"notation NULL, x returned, unmodified.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/to_notation.html","id":null,"dir":"Reference","previous_headings":"","what":"To notation — to_notation","title":"To notation — to_notation","text":"description notation.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/to_notation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"To notation — to_notation","text":"","code":"to_notation"},{"path":"https://matthewheun.github.io/RCLabels/reference/to_notation.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"To notation — to_notation","text":"vector notational symbols provides (\"[b]\") notation.","code":""},{"path":"https://matthewheun.github.io/RCLabels/reference/to_notation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"To notation — to_notation","text":"","code":"to_notation #> pref_start   pref_end suff_start   suff_end  #>         \"\"    \" [to \"    \" [to \"        \"]\""},{"path":"https://matthewheun.github.io/RCLabels/news/index.html","id":"rclabels-0112-2025-03-05","dir":"Changelog","previous_headings":"","what":"RCLabels 0.1.12 (2025-03-05)","title":"RCLabels 0.1.12 (2025-03-05)","text":"Update test-coverage.yaml v4 upload-artifact workflow. Now 381 tests, passing. Test coverage remains 100%.","code":""},{"path":"https://matthewheun.github.io/RCLabels/news/index.html","id":"rclabels-0111-2025-01-13-doi","dir":"Changelog","previous_headings":"","what":"RCLabels 0.1.11 (2025-01-13)","title":"RCLabels 0.1.11 (2025-01-13)","text":"CRAN release: 2025-01-13 match_by_pattern() gains new arguments inf_notation choose_most_specific passed split_noun_pp(). Crucially, new arguments prevent passing via ... grepl() causing error upcoming release matsbyname. Added clearer documentation get_prepositions(). Added new tests illustrate correct results, even unexpected behaviors. short, usually need use bracket_notation (instead from_notation similar) calling get_prepositions().","code":""},{"path":"https://matthewheun.github.io/RCLabels/news/index.html","id":"rclabels-0110-2024-01-26-doi","dir":"Changelog","previous_headings":"","what":"RCLabels 0.1.10 (2024-01-26)","title":"RCLabels 0.1.10 (2024-01-26)","text":"CRAN release: 2024-01-29 Tests now run parallel. Now better test inferring notation notation argument list. Better documentation behavior infer_notation(). Now 374 tests, passing. Test coverage remains 100%.","code":""},{"path":"https://matthewheun.github.io/RCLabels/news/index.html","id":"rclabels-019-2023-12-20-doi","dir":"Changelog","previous_headings":"","what":"RCLabels 0.1.9 (2023-12-20)","title":"RCLabels 0.1.9 (2023-12-20)","text":"CRAN release: 2023-12-21 Added statement need README.Rmd file. Still 372 tests, passing. Test coverage remains 100%.","code":""},{"path":"https://matthewheun.github.io/RCLabels/news/index.html","id":"rclabels-018-2023-12-09-doi","dir":"Changelog","previous_headings":"","what":"RCLabels 0.1.8 (2023-12-09)","title":"RCLabels 0.1.8 (2023-12-09)","text":"CRAN release: 2023-12-10 Fixing GitHub pkgdown website. Still 372 tests, passing. Test coverage remains 100%.","code":""},{"path":"https://matthewheun.github.io/RCLabels/news/index.html","id":"rclabels-017-2023-11-30-doi","dir":"Changelog","previous_headings":"","what":"RCLabels 0.1.7 (2023-11-30)","title":"RCLabels 0.1.7 (2023-11-30)","text":"CRAN release: 2023-12-01 Added code conduct contributing pages documentation. Fixed typos README.Rmd Still 372 tests, passing. Test coverage remains 100%.","code":""},{"path":"https://matthewheun.github.io/RCLabels/news/index.html","id":"rclabels-016-2023-07-28-doi","dir":"Changelog","previous_headings":"","what":"RCLabels 0.1.6 (2023-07-28)","title":"RCLabels 0.1.6 (2023-07-28)","text":"version released CRAN. Changed citation URL point Zenodo. Still 372 tests, passing. Test coverage remains 100%.","code":""},{"path":"https://matthewheun.github.io/RCLabels/news/index.html","id":"rclabels-015-2023-05-04-doi","dir":"Changelog","previous_headings":"","what":"RCLabels 0.1.5 (2023-05-04)","title":"RCLabels 0.1.5 (2023-05-04)","text":"Move latest version GitHub test coverage workflow. version released CRAN. Still 372 tests, passing. Test coverage remains 100%.","code":""},{"path":"https://matthewheun.github.io/RCLabels/news/index.html","id":"rclabels-014-2023-04-25-doi","dir":"Changelog","previous_headings":"","what":"RCLabels 0.1.4 (2023-04-25)","title":"RCLabels 0.1.4 (2023-04-25)","text":"CRAN release: 2023-04-25 Fixed bug list() returned character() returned zero-length inputs. Now 372 tests, passing Test coverage remains 100%.","code":""},{"path":"https://matthewheun.github.io/RCLabels/news/index.html","id":"rclabels-013-2023-01-16-doi","dir":"Changelog","previous_headings":"","what":"RCLabels 0.1.3 (2023-01-16)","title":"RCLabels 0.1.3 (2023-01-16)","text":"version submitted CRAN. purely backend maintenance release. Updated version github actions latest usethis package attempt fix issues actions failing github. Still 368 tests, passing. Test coverage remains 100%.","code":""},{"path":"https://matthewheun.github.io/RCLabels/news/index.html","id":"rclabels-012-2022-10-28-doi","dir":"Changelog","previous_headings":"","what":"RCLabels 0.1.2 (2022-10-28)","title":"RCLabels 0.1.2 (2022-10-28)","text":"CRAN release: 2022-10-28 failing test led new capability: modify_label_pieces() now allows piece = \"pref\" piece = \"suff\". Accepted merge request Hadley Wickham. Submitting character() (empty character vector) paste_pref_suff() now causes error. Use \"\" instead. Fixed bug named values pref suff caused paste_pref_suff() fail. notation elements present multiple locations row column label, error longer thrown. first location now reported. notation inferred, get_piece() similar functions now return full label prefix. (Previously error.) new behavior similar returning entire label prefix notation supplied (inferred) notation applicable label. Added dash_notation. paste_pref_suff() now recycles arguments length 1. functions paste row column label pieces together now vectorized notation arguments. functions get pieces row column labels now infer_notation() default, new argument inf_notation set TRUE. Rename paste_pieces() –> paste_noun_pp(). Rename split_labels() –> split_noun_pp(). Rename RCLabels::prepositions –> RCLabels::prepositions_list bring consistency RCLables::notations_list. New function infer_notation() obtains notation label vector labels. Now includes list known notations: RCLabels::notations_list. Added RCLabels::in_notation. Fixed to_notation example documentation. (example to_notation from_notation.) Improved accuracy documentation get_pps(). Now 368 tests, passing. Test coverage remains 100%.","code":""},{"path":"https://matthewheun.github.io/RCLabels/news/index.html","id":"rclabels-011-2022-03-05-doi","dir":"Changelog","previous_headings":"","what":"RCLabels 0.1.1 (2022-03-05)","title":"RCLabels 0.1.1 (2022-03-05)","text":"CRAN release: 2022-03-05 Added backward compatibility previous versions R via reverting magrittr pipe (%>%) system pipe (|>). Added new notation type first_dot_notation. Now 225 tests, passing. Test coverage remains 100%.","code":""},{"path":"https://matthewheun.github.io/RCLabels/news/index.html","id":"rclabels-010-2022-01-03-doi","dir":"Changelog","previous_headings":"","what":"RCLabels 0.1.0 (2022-01-03)","title":"RCLabels 0.1.0 (2022-01-03)","text":"CRAN release: 2022-01-04 First version used packages, bumping v0.1.0. get_piece(labels = NULL) now returns NULL, expected. return values get_piece() now named appropriately. Added new options piece argument get_piece(): “pps”, “prepositions”, “objects”. RCLabels::prepositions now vector instead list, thereby making downstream use object clearer. keep_pref_suff() –> get_pref_suff() bring consistency get_piece(). keep –> argument name get_pref_suff() bring consistency functions. New wrapper function get_piece() returns requested piece label. Added note README.Rmd installing CRAN. Added project status badge. Added CRAN status badge. Now 216 tests, passing. Test coverage remains 100%.","code":""},{"path":"https://matthewheun.github.io/RCLabels/news/index.html","id":"rclabels-004-2021-12-06","dir":"Changelog","previous_headings":"","what":"RCLabels 0.0.4 (2021-12-06)","title":"RCLabels 0.0.4 (2021-12-06)","text":"CRAN release: 2021-12-06 New function replace_by_pattern(). New function match_by_pattern(). First CRAN release. 187 tests, passing. Test coverage remains 100 %.","code":""},{"path":"https://matthewheun.github.io/RCLabels/news/index.html","id":"rclabels-003","dir":"Changelog","previous_headings":"","what":"RCLabels 0.0.3","title":"RCLabels 0.0.3","text":"Added code coverage. Added automated spell checking package. 156 tests, passing. Test coverage remains 100 %.","code":""},{"path":"https://matthewheun.github.io/RCLabels/news/index.html","id":"rclabels-002","dir":"Changelog","previous_headings":"","what":"RCLabels 0.0.2","title":"RCLabels 0.0.2","text":"First release. Added GitHub pages site. Added vignette. Added extraction functions. Added NEWS.md file track changes package. Refactoring many functions IEATools. 156 tests, passing. Test coverage 100 %.","code":""},{"path":"https://matthewheun.github.io/RCLabels/news/index.html","id":"rclabels-001","dir":"Changelog","previous_headings":"","what":"RCLabels 0.0.1","title":"RCLabels 0.0.1","text":"First commit.","code":""}]
